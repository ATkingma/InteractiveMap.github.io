<!DOCTYPE html>
<html>

<head>
    <title>Arena Breakout Interactive Map</title>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, minimal-ui">

    <!-- Leaflet's CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@latest/dist/leaflet.css" crossorigin="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <link rel="stylesheet" href="../src/css/leaflet-style.css" />
    <link rel="stylesheet" href="../src/css/sidebar-enhancements.css" />

    <!-- Mobile enhancements -->
    <script src="../src/js/mobile-enhancements.js"></script>

    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="https://unpkg.com/leaflet@latest/dist/leaflet.js" crossorigin=""></script>

    <!-- Grouping markers to cluster -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@latest/dist/MarkerCluster.css" crossorigin="" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@latest/dist/MarkerCluster.Default.css" crossorigin="" />
    <script src="https://unpkg.com/leaflet.markercluster@latest/dist/leaflet.markercluster.js" crossorigin=""></script>

    <!-- Nested marker cluster -->
    <script src="https://unpkg.com/leaflet.featuregroup.subgroup@latest/dist/leaflet.featuregroup.subgroup.js" crossorigin=""></script>

    <!-- Interactive sidebar -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-sidebar-v2@latest/css/leaflet-sidebar.min.css" />
    <script src="https://unpkg.com/leaflet-sidebar-v2@latest/js/leaflet-sidebar.min.js"></script>

    <!-- Leaflet editing tools -->
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" crossorigin="" />
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js" crossorigin=""></script>

    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />

    <link rel="stylesheet" href="../src/css/leaflet-style.css" />
    
    <!-- Custom Marker Styles -->
    <style>
        /* Custom marker wrapper - ensure no interference */
        .custom-marker-wrapper {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        
        /* Custom marker icon - force perfect circle with proper border handling */
        .custom-marker-icon {
            width: 20px !important;
            height: 20px !important;
            border: 3px solid white !important;
            border-radius: 50% !important;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4) !important;
            position: relative !important;
            display: block !important;
            transform-origin: center center !important;
            transition: transform 0.2s ease !important;
            /* Force perfect circle - prevent any distortion */
            aspect-ratio: 1 / 1 !important;
            min-width: 20px !important;
            min-height: 20px !important;
            max-width: 20px !important;
            max-height: 20px !important;
            /* Prevent stretching and ensure consistent sizing */
            flex-shrink: 0 !important;
            flex-grow: 0 !important;
            box-sizing: border-box !important;
            overflow: hidden !important;
            /* Force circular border calculation */
            background-clip: padding-box !important;
            /* Ensure the border radius is always calculated from the actual dimensions */
            border-radius: 50% !important;
        }
        
        /* Dynamic color background - maintain perfect circle */
        .custom-marker-icon::before {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background-color: var(--marker-color, #ff6b35) !important;
            border-radius: 50% !important;
            z-index: 1 !important;
            box-sizing: border-box !important;
            /* Ensure inner circle is also perfectly round */
            aspect-ratio: 1 / 1 !important;
        }
        
        /* Hover effect - only scale uniformly, don't distort */
        .custom-marker-wrapper:hover .custom-marker-icon {
            transform: scale(1.15) !important;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.6) !important;
        }
        
        /* Override any Leaflet transforms that might cause distortion */
        .leaflet-marker-icon.custom-marker-wrapper {
            transform-origin: center center !important;
            /* Ensure Leaflet doesn't apply scaling that distorts the circles */
            image-rendering: crisp-edges !important;
        }
        
        /* Prevent zoom-based distortion - lock dimensions during zoom */
        .leaflet-zoom-animated .custom-marker-wrapper {
            transition: none !important;
            transform-origin: center center !important;
        }
        
        .leaflet-zoom-animated .custom-marker-wrapper .custom-marker-icon {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            /* Lock the border calculation during zoom */
            border-width: 3px !important;
            transform: none !important;
        }
        
        .leaflet-zoom-animated .custom-marker-wrapper .custom-marker-icon::before {
            border-radius: 50% !important;
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Force consistent sizing at all zoom levels */
        .leaflet-zoom-animated .custom-marker-icon {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            min-width: 20px !important;
            min-height: 20px !important;
            max-width: 20px !important;
            max-height: 20px !important;
        }
        
        /* Responsive adjustments that maintain aspect ratio */
        @media screen and (max-width: 768px) {
            .custom-marker-icon {
                width: 18px !important;
                height: 18px !important;
                min-width: 18px !important;
                min-height: 18px !important;
                max-width: 18px !important;
                max-height: 18px !important;
                border-width: 2px !important;
                border-radius: 50% !important;
            }
            
            .custom-marker-icon::before {
                border-radius: 50% !important;
            }
        }
        
        /* Ensure perfect circles on high DPI displays */
        @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
            .custom-marker-icon {
                transform: translateZ(0) !important;
                backface-visibility: hidden !important;
                border-radius: 50% !important;
            }
            
            .custom-marker-icon::before {
                border-radius: 50% !important;
            }
        }
        
        /* Additional safeguards to prevent distortion */
        .custom-marker-icon,
        .custom-marker-icon::before {
            /* Force hardware acceleration for smoother rendering */
            will-change: transform !important;
            /* Ensure crisp rendering */
            image-rendering: -webkit-optimize-contrast !important;
            image-rendering: crisp-edges !important;
        }
        
        /* Prevent any parent containers from affecting the marker shape */
        .leaflet-marker-pane .custom-marker-wrapper {
            transform-style: preserve-3d !important;
        }
        
        /* Bulletproof marker wrapper for maximum protection */
        .custom-marker-wrapper-bulletproof {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
            margin: 0 !important;
            transform-origin: center center !important;
            image-rendering: crisp-edges !important;
        }
        
        /* Bulletproof protection against all possible interference */
        .custom-marker-wrapper-bulletproof .custom-marker-icon {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            aspect-ratio: 1 / 1 !important;
            transform-origin: center center !important;
        }
        
        /* Zoom-specific bulletproof protection */
        .leaflet-zoom-animated .custom-marker-wrapper-bulletproof {
            transition: none !important;
            transform-origin: center center !important;
        }
        
        .leaflet-zoom-animated .custom-marker-wrapper-bulletproof .custom-marker-icon {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            transform: none !important;
        }
        
        /* Override any possible external CSS interference */
        .leaflet-marker-icon.custom-marker-wrapper-bulletproof {
            transform-origin: center center !important;
            image-rendering: crisp-edges !important;
        }
        
        /* Force hardware acceleration for bulletproof markers */
        .custom-marker-wrapper-bulletproof .custom-marker-icon,
        .custom-marker-wrapper-bulletproof .custom-marker-icon > div {
            will-change: transform !important;
            backface-visibility: hidden !important;
            transform: translateZ(0) !important;
        }
        
        /* Bulletproof hover effect */
        .custom-marker-wrapper-bulletproof:hover .custom-marker-icon {
            transform: scale(1.15) translateZ(0) !important;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.6) !important;
        }
        
        /* Ensure bullets stay circular on hover */
        .custom-marker-wrapper-bulletproof:hover .custom-marker-icon,
        .custom-marker-wrapper-bulletproof:hover .custom-marker-icon > div {
            border-radius: 50% !important;
            width: 20px !important;
            height: 20px !important;
        }
        
        /* Ultra-bulletproof marker styles with maximum zoom protection */
        .custom-marker-wrapper-ultra-bulletproof {
            transform-origin: center center !important;
            will-change: auto !important;
            transition: none !important;
        }
        
        .zoom-proof-marker {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            aspect-ratio: 1 / 1 !important;
            transform: none !important;
            transform-origin: center center !important;
            will-change: auto !important;
            transition: none !important;
            image-rendering: crisp-edges !important;
            backface-visibility: hidden !important;
            transform-style: flat !important;
        }
        
        .zoom-proof-marker * {
            transform: none !important;
            will-change: auto !important;
            transition: none !important;
            border-radius: 50% !important;
        }
        
        /* BULLETPROOF PROTECTION FOR EXISTING MARKER SYSTEM */
        .custom-marker.marker-type-spawn .marker-circle,
        .custom-marker.marker-type-loot .marker-circle,
        .custom-marker.marker-type-medical .marker-circle,
        .custom-marker.marker-type-weapons .marker-circle,
        .custom-marker.marker-type-extraction .marker-circle,
        .custom-marker.marker-type-danger .marker-circle {
            width: 18px !important;
            height: 18px !important;
            border-radius: 50% !important;
            aspect-ratio: 1 / 1 !important;
            transform: none !important;
            transform-origin: center center !important;
            will-change: auto !important;
            transition: none !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            box-sizing: border-box !important;
        }
        
        .custom-marker.marker-type-spawn .marker-inner,
        .custom-marker.marker-type-loot .marker-inner,
        .custom-marker.marker-type-medical .marker-inner,
        .custom-marker.marker-type-weapons .marker-inner,
        .custom-marker.marker-type-extraction .marker-inner,
        .custom-marker.marker-type-danger .marker-inner {
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            aspect-ratio: 1 / 1 !important;
            transform: none !important;
            will-change: auto !important;
            transition: none !important;
            display: block !important;
            box-sizing: border-box !important;
        }
        
        /* Override ANY zoom-related transforms on existing markers */
        .leaflet-zoom-animated.custom-marker .marker-circle,
        .leaflet-zoom-anim .custom-marker .marker-circle {
            width: 18px !important;
            height: 18px !important;
            border-radius: 50% !important;
            transform: none !important;
            aspect-ratio: 1 / 1 !important;
        }
        
        .leaflet-zoom-animated.custom-marker .marker-inner,
        .leaflet-zoom-anim .custom-marker .marker-inner {
            width: 8px !important;
            height: 8px !important;
            border-radius: 50% !important;
            transform: none !important;
        }
        
        /* Force circle shape during all zoom operations */
        .leaflet-zoom-anim .zoom-proof-marker,
        .leaflet-zoom-animated .zoom-proof-marker,
        .leaflet-zoom-hide .zoom-proof-marker {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            transform: none !important;
            aspect-ratio: 1 / 1 !important;
        }
        
        /* Override any Leaflet zoom transforms for ultra-bulletproof markers */
        .leaflet-marker-icon.custom-marker-wrapper-ultra-bulletproof {
            transform-origin: center center !important;
        }
        
        .leaflet-marker-icon.custom-marker-wrapper-ultra-bulletproof .zoom-proof-marker {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            transform: none !important;
        }
        
        /* Additional zoom event protection */
        .leaflet-zoom-anim .custom-marker-wrapper-ultra-bulletproof .zoom-proof-marker,
        .leaflet-zoom-animated .custom-marker-wrapper-ultra-bulletproof .zoom-proof-marker {
            width: 20px !important;
            height: 20px !important;
            border-radius: 50% !important;
            transform: none !important;
            aspect-ratio: 1 / 1 !important;
        }
    </style>
</head>

<body>
    <!-- Navigation Bar -->
    <nav class="map-navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <a href="index.html" class="brand-link">
                    <i class="fas fa-map-marked-alt"></i>
                    <span class="brand-text">Arena Breakout Maps</span>
                </a>
            </div>
            
            <div class="nav-center">
                <div class="current-page-info">
                    <i class="fas fa-location-dot"></i>
                    <span class="page-indicator">Interactive Map</span>
                    <!-- Map selector dropdown replaces the map name display -->
                    <select id="map-selector" class="map-dropdown">
                        <option value="">Loading maps...</option>
                    </select>
                </div>
            </div>
            
            <div class="nav-actions" id="navActions">
                <!-- Difficulty selector on left for mobile -->
                <select id="difficulty-selector" class="difficulty-dropdown nav-dropdown">
                    <option value="">Loading...</option>
                </select>
                
                <!-- Mobile Menu Button on right -->
                <button class="mobile-nav-btn" id="mobileNavBtn" aria-label="Toggle navigation menu">
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                    <span class="hamburger-line"></span>
                </button>
                
                <!-- Desktop navigation buttons (hidden on mobile) -->
                <button class="nav-btn" onclick="window.location.href='index.html'" title="Back to Main Page">
                    <i class="fas fa-home"></i>
                    <span>Home</span>
                </button>
                <button class="nav-btn" onclick="resetMapView()" title="Reset Map View">
                    <i class="fas fa-refresh"></i>
                    <span>Reset</span>
                </button>
            </div>
        </div>
    </nav>

    <!-- Mobile Navigation Panel (separate from navbar) -->
    <div class="mobile-nav-panel" id="mobileNavPanel">
        <button class="nav-btn" onclick="window.location.href='index.html'" title="Back to Main Page">
            <i class="fas fa-home"></i>
            <span>Home</span>
        </button>
        <button class="nav-btn" onclick="resetMapView()" title="Reset Map View">
            <i class="fas fa-refresh"></i>
            <span>Reset</span>
        </button>
    </div>

    <!-- Top Ad Space -->
    <div id="top-ad" class="ad-space top-ad">
        <div class="ad-content">
            <h3>Premium Ad Spot</h3>
            <p>Your advertisement here - Top banner space</p>
        </div>
    </div>

    <!-- Main Content Area -->
    <div id="main-content">
        <div id="sidebar" class="leaflet-sidebar">
            <!-- Nav tabs -->
            <div class="leaflet-sidebar-tabs">
                <ul role="tablist">
                    <li><a href="#filters" role="tab" data-tooltip="Marker Filtering"><i class="fas fa-filter"></i></a></li>
                    <li><a href="#floors" role="tab" data-tooltip="Floor Selection"><i class="fas fa-building"></i></a></li>
                    <li><a href="#custom-markers" role="tab" data-tooltip="Custom Markers"><i class="fas fa-map-marker-alt"></i></a></li>
                    <li><a href="#drawing" role="tab" data-tooltip="Drawing Tools"><i class="fas fa-pencil-alt"></i></a></li>
                    <li><a href="#info" role="tab" data-tooltip="About & Info"><i class="fas fa-info-circle"></i></a></li>
                    <li><a href="#github" role="tab" data-tooltip="GitHub Repository"><i class="fab fa-github"></i></a></li>
                    <li><a href="#discord" role="tab" data-tooltip="Discord Community"><i class="fab fa-discord"></i></a></li>
                    <li><a href="#settings" role="tab" data-tooltip="Settings & Actions"><i class="fas fa-cog"></i></a></li>
                </ul>
            </div>

            <!-- Tab panes -->
            <div class="leaflet-sidebar-content">
                <!-- Marker Filters Panel -->
                <div class="leaflet-sidebar-pane" id="filters">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fas fa-filter"></i> Marker Filtering
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="filters-container">
                        <div class="filter-section">
                            <h3>🎯 Marker Types</h3>
                            <div class="filter-checkboxes" id="marker-type-filters">
                                <!-- Dynamically populated -->
                            </div>
                        </div>
                        <div class="filter-actions">
                            <button id="select-all-filters" class="control-btn secondary">
                                <i class="fas fa-check-double"></i> Select All
                            </button>
                            <button id="clear-all-filters" class="control-btn secondary">
                                <i class="fas fa-times"></i> Clear All
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Floor Selection Panel -->
                <div class="leaflet-sidebar-pane" id="floors">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fas fa-building"></i> Floor Selection
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="floors-container">
                        <div class="floor-info">
                            <p>Switch between different map floors and levels</p>
                        </div>
                        <div class="floor-selector-container" id="sidebar-floor-selector">
                            <!-- Dynamically populated from JSON data -->
                        </div>
                    </div>
                </div>

                <!-- Custom Markers Panel -->
                <div class="leaflet-sidebar-pane" id="custom-markers">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fas fa-map-marker-alt"></i> Custom Markers
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="custom-markers-container">
                        <div class="marker-creation-section">
                            <div class="create-instructions">
                                <p><i class="fas fa-info-circle"></i> Click the "Place Marker" button, then click anywhere on the map to add your custom marker.</p>
                                <div class="current-floor-indicator">
                                    <i class="fas fa-building"></i> 
                                    <span>Creating on: <strong id="current-floor-indicator">Ground Floor</strong></span>
                                </div>
                            </div>
                            
                            <div class="marker-form">
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="marker-name">Marker Name</label>
                                        <input type="text" id="marker-name" placeholder="Enter marker name" maxlength="50">
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group">
                                        <label for="marker-description">Description (Optional)</label>
                                        <textarea id="marker-description" placeholder="Enter description..." rows="2" maxlength="200"></textarea>
                                    </div>
                                </div>
                                
                                <div class="form-row">
                                    <div class="form-group half-width">
                                        <label for="marker-type">Type</label>
                                        <select id="marker-type">
                                            <option value="custom">Custom</option>
                                            <option value="objective">Objective</option>
                                            <option value="loot">Loot</option>
                                            <option value="danger">Danger</option>
                                            <option value="note">Note</option>
                                        </select>
                                    </div>
                                    <div class="form-group half-width">
                                        <label for="marker-color">Color</label>
                                        <input type="color" id="marker-color" value="#ff6b35">
                                    </div>
                                </div>
                                
                                <div class="marker-actions">
                                    <button id="place-marker-btn" class="control-btn primary">
                                        <i class="fas fa-map-marker-alt"></i> Place Marker on Map
                                    </button>
                                    <button id="cancel-marker-btn" class="control-btn secondary" style="display: none;">
                                        <i class="fas fa-times"></i> Cancel
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="custom-markers-list">
                            <div class="list-header">
                                <h3>Your Markers (<span id="marker-count">0</span>)</h3>
                                <div class="list-actions">
                                    <button id="delete-all-markers" class="control-btn danger small">
                                        <i class="fas fa-trash-alt"></i> Clear All
                                    </button>
                                </div>
                            </div>
                            <div id="custom-markers-list" class="markers-list">
                                <div class="no-markers">
                                    <i class="fas fa-map-marker-alt"></i>
                                    <p>No custom markers yet</p>
                                    <small>Create your first marker by clicking "Place Marker on Map"</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Drawing Tools Panel -->
                <div class="leaflet-sidebar-pane" id="drawing">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fas fa-pencil-alt"></i> Drawing Tools
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="drawing-container">
                        <div class="drawing-tools">
                            <h3>Drawing Mode</h3>
                            <div class="tool-buttons">
                                <button id="draw-line" class="tool-btn" data-tool="line">
                                    <i class="fas fa-minus"></i> Line
                                </button>
                                <button id="draw-polygon" class="tool-btn" data-tool="polygon">
                                    <i class="fas fa-draw-polygon"></i> Polygon
                                </button>
                                <button id="draw-circle" class="tool-btn" data-tool="circle">
                                    <i class="fas fa-circle"></i> Circle
                                </button>
                                <button id="draw-rectangle" class="tool-btn" data-tool="rectangle">
                                    <i class="fas fa-square"></i> Rectangle
                                </button>
                            </div>
                        </div>
                        <div class="drawing-options">
                            <h3>Style Options</h3>
                            <div class="style-controls">
                                <div class="form-group">
                                    <label for="draw-color">Color:</label>
                                    <input type="color" id="draw-color" value="#ff6b35">
                                </div>
                                <div class="form-group">
                                    <label for="draw-opacity">Opacity:</label>
                                    <input type="range" id="draw-opacity" min="0" max="1" step="0.1" value="0.7">
                                    <span id="opacity-value">70%</span>
                                </div>
                                <div class="form-group">
                                    <label for="draw-weight">Line Weight:</label>
                                    <input type="range" id="draw-weight" min="1" max="10" value="3">
                                    <span id="weight-value">3px</span>
                                </div>
                            </div>
                        </div>
                        <div class="drawing-actions">
                            <button id="clear-drawings" class="control-btn danger">
                                <i class="fas fa-eraser"></i> Clear All Drawings
                            </button>
                            <button id="toggle-drawing-mode" class="control-btn secondary">
                                <i class="fas fa-eye-slash"></i> Disable Drawing
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Info Panel -->
                <div class="leaflet-sidebar-pane" id="info">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fas fa-info-circle"></i> About
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="info-container">
                        <div class="site-info">
                            <h3>Arena Breakout Interactive Map</h3>
                            <p>Welcome to the most comprehensive Arena Breakout interactive map experience. This tool provides real-time map navigation, custom marker placement, and advanced filtering capabilities.</p>
                            
                            <h4>Features:</h4>
                            <ul>
                                <li><strong>Multi-floor Navigation:</strong> Switch between different map levels seamlessly</li>
                                <li><strong>Advanced Filtering:</strong> Filter markers by type (ammo, vaults, jackets, medboxes, spawn points, exits, etc.)</li>
                                <li><strong>Custom Markers:</strong> Create and manage your own markers with custom colors</li>
                                <li><strong>Drawing Tools:</strong> Draw lines, polygons, circles, and rectangles for planning</li>
                                <li><strong>Real-time Coordinates:</strong> Track mouse position and navigate to specific coordinates</li>
                                <li><strong>Grid System:</strong> Toggle grid overlay for precise positioning</li>
                            </ul>

                            <h4>How to Use:</h4>
                            <ol>
                                <li><strong>Navigation:</strong> Use mouse wheel to zoom, click and drag to pan</li>
                                <li><strong>Markers:</strong> Click on any marker to see detailed information</li>
                                <li><strong>Filtering:</strong> Use the filter panel to show/hide specific marker types</li>
                                <li><strong>Custom Markers:</strong> Create your own markers by clicking on the map or entering coordinates</li>
                                <li><strong>Drawing:</strong> Use drawing tools to mark routes, areas, or strategies</li>
                                <li><strong>Floors:</strong> Switch between floors using the floor control or sidebar</li>
                            </ol>

                            <div class="version-info">
                                <p><strong>Version:</strong> 2.0.0</p>
                                <p><strong>Last Updated:</strong> December 2024</p>
                                <p><strong>Map Data:</strong> Community sourced and verified</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- GitHub Panel -->
                <div class="leaflet-sidebar-pane" id="github">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fab fa-github"></i> GitHub Repository
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="github-container">
                        <div class="github-info">
                            <h3>Open Source Project</h3>
                            <p>This Arena Breakout Interactive Map is an open-source project. All map data, JSON files, and source code are available on GitHub.</p>
                            
                            <div class="github-links">
                                <a href="https://github.com/ATkingma/InteractiveMap.github.io" target="_blank" class="control-btn primary">
                                    <i class="fab fa-github"></i> View Repository
                                </a>
                                <a href="https://github.com/ATkingma/InteractiveMap.github.io/tree/main/maps" target="_blank" class="control-btn secondary">
                                    <i class="fas fa-folder"></i> Map Data (JSON)
                                </a>
                                <a href="https://github.com/ATkingma/InteractiveMap.github.io/issues" target="_blank" class="control-btn secondary">
                                    <i class="fas fa-bug"></i> Report Issues
                                </a>
                            </div>

                            <h4>Contributing</h4>
                            <p>We welcome contributions! You can help by:</p>
                            <ul>
                                <li>Updating map data and marker locations</li>
                                <li>Adding new maps and floors</li>
                                <li>Reporting bugs and issues</li>
                                <li>Suggesting new features</li>
                                <li>Improving documentation</li>
                            </ul>

                            <h4>Map Data Structure</h4>
                            <p>All map data is stored in JSON format with the following structure:</p>
                            <div class="code-block">
                                <code>
                                    maps/<br>
                                    ├── arena-breakout.json<br>
                                    ├── armory.json<br>
                                    └── [map-name].json
                                </code>
                            </div>

                            <div class="github-stats">
                                <h4>Repository Stats</h4>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <strong>Language:</strong> JavaScript
                                    </div>
                                    <div class="stat-item">
                                        <strong>License:</strong> MIT
                                    </div>
                                    <div class="stat-item">
                                        <strong>Maps:</strong> 2+
                                    </div>
                                    <div class="stat-item">
                                        <strong>Contributors:</strong> Community
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Discord Panel -->
                <div class="leaflet-sidebar-pane" id="discord">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fab fa-discord"></i> Community Discord
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="discord-container">
                        <div class="discord-info">
                            <h3>Join Our Community</h3>
                            <p>Connect with other Arena Breakout players, share strategies, get help with the map, and stay updated with the latest features.</p>
                            
                            <div class="discord-features">
                                <h4>What you'll find:</h4>
                                <ul>
                                    <li><strong>🗺️ Map Discussion:</strong> Share findings and discuss map strategies</li>
                                    <li><strong>🚀 Feature Requests:</strong> Suggest new features for the interactive map</li>
                                    <li><strong>🐛 Bug Reports:</strong> Report issues and get quick support</li>
                                    <li><strong>📡 Updates:</strong> Get notified about new map releases</li>
                                    <li><strong>🎮 General Chat:</strong> Discuss Arena Breakout gameplay</li>
                                    <li><strong>💡 Tips & Tricks:</strong> Share and learn advanced strategies</li>
                                </ul>
                            </div>

                            <div class="discord-invite">
                                <a href="https://discord.gg/your-discord-server" target="_blank" class="control-btn primary discord-btn">
                                    <i class="fab fa-discord"></i> Join Discord Server
                                </a>
                            </div>

                            <div class="community-rules">
                                <h4>Community Guidelines</h4>
                                <ul>
                                    <li>Be respectful to all community members</li>
                                    <li>Stay on topic in appropriate channels</li>
                                    <li>No spam or excessive self-promotion</li>
                                    <li>Help newcomers and share knowledge</li>
                                    <li>Report bugs constructively with details</li>
                                </ul>
                            </div>

                            <div class="discord-stats">
                                <h4>Server Info</h4>
                                <div class="stats-grid">
                                    <div class="stat-item">
                                        <strong>Members:</strong> 500+
                                    </div>
                                    <div class="stat-item">
                                        <strong>Channels:</strong> 10+
                                    </div>
                                    <div class="stat-item">
                                        <strong>Active:</strong> 24/7
                                    </div>
                                    <div class="stat-item">
                                        <strong>Language:</strong> English
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Settings Panel -->
                <div class="leaflet-sidebar-pane" id="settings">
                    <h1 class="leaflet-sidebar-header">
                        <i class="fas fa-cog"></i> Settings & Actions
                        <span class="leaflet-sidebar-close"><i class="fas fa-caret-left"></i></span>
                    </h1>
                    <div class="settings-container">
                        <div class="actions-section">
                            <h3>Data Management</h3>
                            <div class="data-info">
                                <p>Export your custom markers and settings, or import previously saved data.</p>
                            </div>
                            <div class="action-buttons">
                                <button id="export-all-data" class="control-btn primary">
                                    <i class="fas fa-download"></i> Export All Data
                                </button>
                                <button id="import-data" class="control-btn secondary">
                                    <i class="fas fa-upload"></i> Import Data
                                </button>
                                <input type="file" id="import-file" accept=".json" style="display: none;">
                            </div>
                            <div class="data-stats">
                                <div class="stat-row">
                                    <span class="stat-label">Custom Markers:</span>
                                    <span class="stat-value" id="stats-markers">0</span>
                                </div>
                                <div class="stat-row">
                                    <span class="stat-label">Storage Used:</span>
                                    <span class="stat-value" id="stats-storage">0 KB</span>
                                </div>
                            </div>
                        </div>

                        <div class="danger-section">
                            <h3>Danger Zone</h3>
                            <div class="danger-actions">
                                <button id="hard-delete" class="control-btn danger">
                                    <i class="fas fa-trash"></i> Delete All Custom Data
                                </button>
                                <button id="hard-reset" class="control-btn danger">
                                    <i class="fas fa-undo"></i> Reset Map View
                                </button>
                            </div>
                            <div class="danger-warning">
                                <p><strong>⚠️ Warning:</strong> These actions cannot be undone!</p>
                                <ul>
                                    <li><strong>Delete All:</strong> Removes all custom markers and saved data</li>
                                    <li><strong>Reset Map:</strong> Resets map to initial position and zoom</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="map"></div>
        
        <!-- Independent Sidebar Close Control -->
        <div id="sidebar-close-control" class="sidebar-close-control">
            <a href="#" class="sidebar-close-btn" onclick="closeSidebar(); return false;" title="Close Sidebar">
                <i class="fas fa-times"></i>
            </a>
        </div>
        
        <!-- Bottom Ad Space -->
        <div id="bottom-ad" class="ad-space bottom-ad">
            <div class="ad-content">
                <h3>Featured Advertisement</h3>
                <p>Your advertisement here - Featured banner space</p>
            </div>
        </div>
        
    </div>

    <!-- include classes -->
    <script src="../src/js/leaflet/custom_layers.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/interactive_layer.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/interactive_map.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/share_marker.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/utils.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/floor_control.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/map_data_manager.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/enhanced_marker_system.js" type="text/javascript"></script>
    <script src="../src/js/leaflet/enhanced_map_features.js" type="text/javascript"></script>

    <!-- include map specific stuff -->
    <script src="../src/js/leaflet/arena_breakout_map.js" type="text/javascript"></script>
    
    <script>
        // Mobile Navigation Menu Functionality
        function initMobileNavigation() {
            const mobileNavBtn = document.getElementById('mobileNavBtn');
            const mobileNavPanel = document.getElementById('mobileNavPanel');
            
            if (!mobileNavBtn || !mobileNavPanel) return;
            
            // Create and add overlay
            const overlay = document.createElement('div');
            overlay.className = 'mobile-nav-overlay';
            document.body.appendChild(overlay);
            
            // Toggle mobile navigation menu
            const toggleNavigation = (isOpen) => {
                mobileNavBtn.classList.toggle('active', isOpen);
                mobileNavPanel.classList.toggle('active', isOpen);
                overlay.classList.toggle('active', isOpen);
                
                // Prevent scrolling when menu is open
                document.body.style.overflow = isOpen ? 'hidden' : '';
                
                // Update aria attributes
                mobileNavBtn.setAttribute('aria-expanded', isOpen);
            };
            
            mobileNavBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = !mobileNavBtn.classList.contains('active');
                toggleNavigation(isOpen);
            });
            
            // Close menu when clicking overlay
            overlay.addEventListener('click', () => toggleNavigation(false));
            
            // Close menu on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && mobileNavBtn.classList.contains('active')) {
                    toggleNavigation(false);
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (window.innerWidth > 1024) {
                    toggleNavigation(false);
                }
            });
            
            // Close menu when clicking nav buttons
            const navButtons = mobileNavPanel.querySelectorAll('.nav-btn');
            navButtons.forEach(button => {
                button.addEventListener('click', () => toggleNavigation(false));
            });
            
            // Initialize accessibility attributes
            mobileNavBtn.setAttribute('aria-expanded', 'false');
        }

        // Modern Sidebar Functions (Modified for mobile-only removal)
        function toggleSidebar() {
            // Only work on desktop (larger than 1024px)
            if (window.innerWidth <= 1024) {
                console.log('Sidebar disabled on mobile and tablets');
                return;
            }
            
            var sidebar = document.getElementById('sidebar');
            if (sidebar) {
                if (sidebar.classList.contains('collapsed')) {
                    openSidebar();
                } else {
                    closeSidebar();
                }
            }
        }
        
        function openSidebar() {
            // Only work on desktop
            if (window.innerWidth <= 1024) {
                return;
            }
            
            var sidebar = document.getElementById('sidebar');
            var closeControl = document.getElementById('sidebar-close-control');
            if (sidebar) {
                sidebar.classList.remove('collapsed');
                adjustMapControls();
            }
            if (closeControl) {
                closeControl.classList.add('visible');
            }
        }
        
        function closeSidebar() {
            // Only work on desktop
            if (window.innerWidth <= 1024) {
                return;
            }
            
            var sidebar = document.getElementById('sidebar');
            var closeControl = document.getElementById('sidebar-close-control');
            if (sidebar) {
                sidebar.classList.add('collapsed');
                adjustMapControls();
            }
            if (closeControl) {
                closeControl.classList.remove('visible');
            }
        }
        
        function adjustMapControls() {
            // Force map to resize and reposition controls
            setTimeout(() => {
                if (window.interactive_map && window.interactive_map.getMap()) {
                    window.interactive_map.getMap().invalidateSize();
                }
            }, 300);
        }
        
        function resetMapView() {
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                // Reset to default bounds
                const mapBounds = [[0, 0], [2158, 4078]];
                map.fitBounds(mapBounds, {
                    padding: [50, 50],
                    maxZoom: -1
                });
                console.log('Map view reset to default');
            }
        }
        
        function updateMapName() {
            const mapNameElement = document.getElementById('current-map-name');
            let selectedMap = sessionStorage.getItem('selectedMap') || 'arena-breakout';
            
            // If we have loaded map data, use the actual map name from the data
            if (window.mapDataManager && window.mapDataManager.mapData) {
                selectedMap = window.mapDataManager.mapData.mapName;
            }
            
            // Format map name for display
            const displayName = selectedMap
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
                
            if (mapNameElement) {
                mapNameElement.textContent = displayName;
            }
            
            // Also update page title
            document.title = `${displayName} - Arena Breakout Interactive Map`;
        }

        // ==================== DROPDOWN FUNCTIONALITY ====================
        
        // Protect against dropdown clearing by overriding innerHTML setter
        function protectDropdownFromClearing() {
            console.log('🛡️ Setting up dropdown innerHTML protection...');
            
            const difficultySelector = document.getElementById('difficulty-selector');
            if (!difficultySelector) return;
            
            // Store the original innerHTML setter
            const originalInnerHTMLSetter = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set;
            
            // Override the innerHTML setter specifically for this element
            Object.defineProperty(difficultySelector, 'innerHTML', {
                set: function(value) {
                    // If someone tries to clear the dropdown, log it and potentially prevent it
                    if (value === '' || value === '<option value="">Loading...</option>') {
                        console.warn('🚨 Attempt to clear difficulty dropdown detected!');
                        console.trace('Stack trace of clearing attempt');
                        
                        // If we have protected options, restore them instead
                        if (window.protectedDifficultyOptions && window.protectedDifficultyOptions.length > 0) {
                            console.log('🔄 Preventing clear and restoring options instead');
                            
                            // Use the original setter to clear first
                            originalInnerHTMLSetter.call(this, '');
                            
                            // Then add our protected options back
                            window.protectedDifficultyOptions.forEach(optionData => {
                                const option = document.createElement('option');
                                option.value = optionData.value;
                                option.textContent = optionData.text;
                                this.appendChild(option);
                            });
                            
                            // Restore saved value
                            const savedDifficulty = sessionStorage.getItem('selectedDifficulty');
                            if (savedDifficulty && this.querySelector(`option[value="${savedDifficulty}"]`)) {
                                this.value = savedDifficulty;
                            }
                            
                            return; // Don't execute the clearing
                        }
                    }
                    
                    // For any other content, use the original setter
                    originalInnerHTMLSetter.call(this, value);
                },
                get: function() {
                    return this.innerHTML;
                },
                configurable: true
            });
            
            console.log('✅ Dropdown innerHTML protection activated');
        }
        
        // Utility functions for formatting
        function formatMapName(mapName) {
            return mapName
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');
        }
        
        function formatDifficultyName(difficulty) {
            return difficulty.charAt(0).toUpperCase() + difficulty.slice(1);
        }
        
        // Notification system
        function showNotification(message, type = 'info') {
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => notification.remove());
            
            // Create new notification
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Style the notification - positioned at top right
            notification.style.cssText = `
                position: fixed;
                top: 80px;
                right: 20px;
                background: ${type === 'error' ? '#ff4444' : type === 'success' ? '#ff8c00' : '#ff8c00'};
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                z-index: 20000;
                font-weight: bold;
                max-width: 300px;
                word-wrap: break-word;
                border: 2px solid ${type === 'error' ? '#ff6666' : type === 'success' ? '#ffb3475' : '#ffb347'};
            `;
            
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        // Load available maps from the maps folder
        async function loadAvailableMaps() {
            console.log('Loading available maps...');
            
            try {
                // List of known maps (you can expand this dynamically if needed)
                const availableMaps = ['arena-breakout', 'armory'];
                
                const mapSelector = document.getElementById('map-selector');
                if (!mapSelector) {
                    console.error('Map selector not found');
                    return;
                }
                
                // Clear existing options
                mapSelector.innerHTML = '';
                
                // Add maps as options
                for (const mapName of availableMaps) {
                    try {
                        // Test if the map file exists
                        const response = await fetch(`../maps/${mapName}.json`);
                        if (response.ok) {
                            const option = document.createElement('option');
                            option.value = mapName;
                            option.textContent = formatMapName(mapName);
                            mapSelector.appendChild(option);
                            console.log('Added map option:', mapName);
                        }
                    } catch (error) {
                        console.warn(`Map ${mapName} not available:`, error);
                    }
                }
                
                // Set current selection
                const currentMap = sessionStorage.getItem('selectedMap') || 'arena-breakout';
                if (mapSelector.querySelector(`option[value="${currentMap}"]`)) {
                    mapSelector.value = currentMap;
                } else if (mapSelector.options.length > 0) {
                    mapSelector.value = mapSelector.options[0].value;
                    sessionStorage.setItem('selectedMap', mapSelector.options[0].value);
                }
                
                console.log('Available maps loaded successfully');
                
            } catch (error) {
                console.error('Error loading available maps:', error);
                
                // Fallback
                const mapSelector = document.getElementById('map-selector');
                if (mapSelector) {
                    mapSelector.innerHTML = '<option value="arena-breakout">Arena Breakout</option>';
                    mapSelector.value = 'arena-breakout';
                }
            }
        }
        
        // Load difficulties for a specific map
        async function loadDifficultiesForMap(mapName) {
            console.log('Loading difficulties for map:', mapName);
            
            try {
                const response = await fetch(`../maps/${mapName}.json`);
                if (!response.ok) {
                    throw new Error(`Map not found: ${response.status}`);
                }
                
                const mapData = await response.json();
                console.log('Map data loaded:', mapData);
                
                const difficultySelector = document.getElementById('difficulty-selector');
                
                if (!difficultySelector) {
                    console.error('Difficulty selector not found');
                    return {};
                }
                
                // Store current value before clearing
                const currentValue = difficultySelector.value;
                
                // Clear existing options
                difficultySelector.innerHTML = '';
                
                if (mapData.difficulties) {
                    const difficultyKeys = Object.keys(mapData.difficulties);
                    console.log('Found difficulties:', difficultyKeys);
                    
                    if (difficultyKeys.length === 0) {
                        console.warn('No difficulties found in map data');
                        throw new Error('No difficulties found');
                    }
                    
                    // Get the difficulty keys directly from the JSON
                    difficultyKeys.forEach(difficultyKey => {
                        const option = document.createElement('option');
                        option.value = difficultyKey;
                        option.textContent = formatDifficultyName(difficultyKey);
                        difficultySelector.appendChild(option);
                        console.log('Added difficulty option:', difficultyKey);
                    });
                    
                    // Set saved difficulty or default
                    const savedDifficulty = sessionStorage.getItem('selectedDifficulty');
                    let targetDifficulty = null;
                    
                    // Priority: saved difficulty > current value > first available
                    if (savedDifficulty && difficultySelector.querySelector(`option[value="${savedDifficulty}"]`)) {
                        targetDifficulty = savedDifficulty;
                        console.log('Using saved difficulty:', savedDifficulty);
                    } else if (currentValue && difficultySelector.querySelector(`option[value="${currentValue}"]`)) {
                        targetDifficulty = currentValue;
                        console.log('Using previous difficulty:', currentValue);
                    } else {
                        targetDifficulty = difficultyKeys[0];
                        console.log('Using first available difficulty:', targetDifficulty);
                    }
                    
                    if (targetDifficulty) {
                        difficultySelector.value = targetDifficulty;
                        sessionStorage.setItem('selectedDifficulty', targetDifficulty);
                    }
                    
                    // Store the options globally for protection
                    window.protectedDifficultyOptions = difficultyKeys.map(key => ({
                        value: key,
                        text: formatDifficultyName(key)
                    }));
                    
                    // Setup protection after a delay
                    setTimeout(() => {
                        protectDifficultyDropdown();
                    }, 500);
                    
                } else {
                    console.log('No difficulties found in map data, using defaults');
                    // Fallback to default difficulties if none specified in JSON
                    const defaultDifficulties = ['normal', 'hard', 'nightmare'];
                    defaultDifficulties.forEach(diff => {
                        const option = document.createElement('option');
                        option.value = diff;
                        option.textContent = formatDifficultyName(diff);
                        difficultySelector.appendChild(option);
                        console.log('Added default difficulty option:', diff);
                    });
                    
                    difficultySelector.value = 'normal';
                    sessionStorage.setItem('selectedDifficulty', 'normal');
                    
                    // Store the options globally for protection
                    window.protectedDifficultyOptions = defaultDifficulties.map(diff => ({
                        value: diff,
                        text: formatDifficultyName(diff)
                    }));
                    
                    // Setup protection
                    setTimeout(() => {
                        protectDifficultyDropdown();
                    }, 500);
                }
                
                console.log('Difficulty selector populated with', difficultySelector.options.length, 'options');
                console.log('Selected difficulty:', difficultySelector.value);
                
                return mapData.difficulties || {};
                
            } catch (error) {
                console.error('Error loading difficulties for map:', error);
                
                // Fallback difficulties
                const difficultySelector = document.getElementById('difficulty-selector');
                if (difficultySelector) {
                    difficultySelector.innerHTML = '';
                    
                    const defaultDifficulties = ['normal', 'hard', 'nightmare'];
                    defaultDifficulties.forEach(diff => {
                        const option = document.createElement('option');
                        option.value = diff;
                        option.textContent = formatDifficultyName(diff);
                        difficultySelector.appendChild(option);
                        console.log('Added fallback difficulty option:', diff);
                    });
                    
                    difficultySelector.value = 'normal';
                    sessionStorage.setItem('selectedDifficulty', 'normal');
                    
                    // Store the options globally for protection
                    window.protectedDifficultyOptions = defaultDifficulties.map(diff => ({
                        value: diff,
                        text: formatDifficultyName(diff)
                    }));
                    
                    // Setup protection
                    setTimeout(() => {
                        protectDifficultyDropdown();
                    }, 500);
                }
                
                return {};
            }
        }
        
        // Protection function to prevent other scripts from clearing the dropdown
        function protectDifficultyDropdown() {
            const difficultySelector = document.getElementById('difficulty-selector');
            if (!difficultySelector || !window.protectedDifficultyOptions) {
                console.log('Protection not set up - missing selector or options');
                return;
            }
            
            console.log('Setting up dropdown protection for', window.protectedDifficultyOptions.length, 'options');
            
            // Create a MutationObserver to watch for changes
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        // Check if the dropdown was cleared or has only loading text
                        if (difficultySelector.options.length === 0 || 
                            (difficultySelector.options.length === 1 && 
                             (difficultySelector.options[0].textContent === 'Loading...' || 
                              difficultySelector.options[0].value === ''))) {
                            
                            console.warn('🚨 Difficulty dropdown was cleared! Restoring options...');
                            console.trace('Stack trace of clearing operation');
                            
                            // Restore the options immediately
                            difficultySelector.innerHTML = '';
                            window.protectedDifficultyOptions.forEach(optionData => {
                                const option = document.createElement('option');
                                option.value = optionData.value;
                                option.textContent = optionData.text;
                                difficultySelector.appendChild(option);
                            });
                            
                            // Restore the selected value
                            const savedDifficulty = sessionStorage.getItem('selectedDifficulty');
                            if (savedDifficulty && difficultySelector.querySelector(`option[value="${savedDifficulty}"]`)) {
                                difficultySelector.value = savedDifficulty;
                                console.log('✅ Restored dropdown with', difficultySelector.options.length, 'options and selected:', savedDifficulty);
                            } else if (difficultySelector.options.length > 0) {
                                difficultySelector.value = difficultySelector.options[0].value;
                                console.log('✅ Restored dropdown with', difficultySelector.options.length, 'options and selected first option');
                            }
                        }
                    }
                });
            });
            
            // Start observing
            observer.observe(difficultySelector, {
                childList: true,
                subtree: true
            });
            
            // Also set up a periodic check as backup
            const intervalId = setInterval(() => {
                if (difficultySelector.options.length === 0 || 
                    (difficultySelector.options.length === 1 && 
                     (difficultySelector.options[0].textContent === 'Loading...' || 
                      difficultySelector.options[0].value === ''))) {
                    
                    console.warn('⏰ Periodic check: Difficulty dropdown is empty! Restoring...');
                    
                    if (window.protectedDifficultyOptions) {
                        difficultySelector.innerHTML = '';
                        window.protectedDifficultyOptions.forEach(optionData => {
                            const option = document.createElement('option');
                            option.value = optionData.value;
                            option.textContent = optionData.text;
                            difficultySelector.appendChild(option);
                        });
                        
                        const savedDifficulty = sessionStorage.getItem('selectedDifficulty');
                        if (savedDifficulty && difficultySelector.querySelector(`option[value="${savedDifficulty}"]`)) {
                            difficultySelector.value = savedDifficulty;
                        } else if (difficultySelector.options.length > 0) {
                            difficultySelector.value = difficultySelector.options[0].value;
                        }
                        
                        console.log('✅ Periodic restore completed with', difficultySelector.options.length, 'options');
                    }
                }
            }, 1000); // Check every second
            
            // Store the interval ID so we can clear it later if needed
            window.protectionIntervalId = intervalId;
            
            console.log('✅ Dropdown protection system activated');
        }
        
        // Initialize map and difficulty selectors
        async function initializeMapAndDifficultySelectors() {
            console.log('Initializing map and difficulty selectors...');
            
            try {
                // Load available maps
                await loadAvailableMaps();
                
                // Get current map from session storage or default
                const currentMap = sessionStorage.getItem('selectedMap') || 'arena-breakout';
                const mapSelector = document.getElementById('map-selector');
                
                console.log('Current map:', currentMap);
                console.log('Available options:', Array.from(mapSelector.options).map(opt => opt.value));
                
                // Set current map selection
                if (mapSelector.querySelector(`option[value="${currentMap}"]`)) {
                    mapSelector.value = currentMap;
                    console.log('Set map selector to:', currentMap);
                } else {
                    // If saved map doesn't exist, use the first available map
                    const firstOption = mapSelector.options[0];
                    if (firstOption && firstOption.value) {
                        mapSelector.value = firstOption.value;
                        sessionStorage.setItem('selectedMap', firstOption.value);
                        console.log('Set map selector to first available:', firstOption.value);
                    }
                }
                
                // Load difficulties for the current map
                const selectedMap = mapSelector.value || 'arena-breakout';
                console.log('Loading difficulties for map:', selectedMap);
                await loadDifficultiesForMap(selectedMap);
                
                // Set up saved difficulty
                const difficultySelector = document.getElementById('difficulty-selector');
                const savedDifficulty = sessionStorage.getItem('selectedDifficulty');
                
                if (savedDifficulty && difficultySelector.querySelector(`option[value="${savedDifficulty}"]`)) {
                    difficultySelector.value = savedDifficulty;
                    console.log('Set difficulty selector to saved:', savedDifficulty);
                } else if (difficultySelector.options.length > 0) {
                    difficultySelector.value = difficultySelector.options[0].value;
                    sessionStorage.setItem('selectedDifficulty', difficultySelector.options[0].value);
                    console.log('Set difficulty selector to first available:', difficultySelector.options[0].value);
                }
                
            } catch (error) {
                console.error('Error initializing selectors:', error);
            }
            
            // Set up event listeners for dropdowns
            const mapSelector = document.getElementById('map-selector');
            const difficultySelector = document.getElementById('difficulty-selector');
            
            if (mapSelector) {
                mapSelector.addEventListener('change', async function() {
                    const selectedMap = this.value;
                    console.log('Map changed to:', selectedMap);
                    sessionStorage.setItem('selectedMap', selectedMap);
                    
                    // Load difficulties for the new map
                    try {
                        await loadDifficultiesForMap(selectedMap);
                        showNotification(`Switched to ${formatMapName(selectedMap)}`);
                        
                        // Reload the page to load new map
                        window.location.reload();
                    } catch (error) {
                        console.error('Error switching map:', error);
                        showNotification(`Error switching to ${formatMapName(selectedMap)}`, 'error');
                    }
                });
            }
            
            if (difficultySelector) {
                difficultySelector.addEventListener('change', async function() {
                    const selectedDifficulty = this.value;
                    console.log('=== DIFFICULTY CHANGE EVENT ===');
                    console.log('Difficulty changed to:', selectedDifficulty);
                    sessionStorage.setItem('selectedDifficulty', selectedDifficulty);
                    
                    showNotification(`Switching to ${formatDifficultyName(selectedDifficulty)}...`);
                    
                    // Add a longer delay to ensure all systems are ready and force a complete reload
                    setTimeout(async () => {
                        try {
                            console.log('Starting difficulty change process...');
                            
                            // Force complete marker reload (without applyDifficultySettings to avoid interference)
                            await reloadMarkersForDifficulty(selectedDifficulty);
                            
                            // Refresh floor selector with new difficulty data (immediate and delayed)
                            if (window.forceRefreshFloorSelector) {
                                console.log('Force refreshing floor selector for new difficulty...');
                                window.forceRefreshFloorSelector();
                            }
                            
                            // Also do a delayed refresh to catch any late-loading data
                            setTimeout(() => {
                                if (window.refreshFloorSelector) {
                                    console.log('Delayed floor selector refresh...');
                                    window.refreshFloorSelector();
                                }
                            }, 1000);
                            
                            // Additional safety check - force another update
                            setTimeout(() => {
                                if (window.markerSystem && typeof window.markerSystem.updateMarkers === 'function') {
                                    console.log('Safety update - forcing final marker refresh...');
                                    window11.markerSystem.updateMarkers();
                                }
                            }, 500);
                            
                            showNotification(`Difficulty set to ${formatDifficultyName(selectedDifficulty)}`, 'success');
                            console.log('=== DIFFICULTY CHANGE COMPLETED ===');
                            
                        } catch (error) {
                            console.error('=== ERROR IN DIFFICULTY CHANGE ===', error);
                            showNotification(`Error loading ${formatDifficultyName(selectedDifficulty)} markers`, 'error');
                        }
                    }, 100); // Reduced delay for faster response
                });
            }
            
            // Log final state
            console.log('Final state - Map options:', mapSelector?.options.length || 0);
            console.log('Final state - Difficulty options:', difficultySelector?.options.length || 0);
        }
        
        // Helper function to check if marker system is ready
        function isMarkerSystemReady() {
            return window.markerSystem && 
                   window.mapDataManager && 
                   window.mapDataManager.mapData &&
                   typeof window.markerSystem.updateMarkers === 'function' &&
                   typeof window.markerSystem.clearMarkers === 'function';
        }
        
        // Helper function to wait for marker system to be ready
        function waitForMarkerSystem(maxWait = 5000) {
            return new Promise((resolve, reject) => {
                const startTime = Date.now();
                
                const checkReady = () => {
                    if (isMarkerSystemReady()) {
                        console.log('Marker system is ready!');
                        resolve();
                    } else if (Date.now() - startTime > maxWait) {
                        reject(new Error('Marker system not ready after maximum wait time'));
                    } else {
                        setTimeout(checkReady, 100);
                    }
                };
                
                checkReady();
            });
        }
        
        // Reload markers for difficulty
        // Reload markers for difficulty - simplified and safe approach
        async function reloadMarkersForDifficulty(difficulty) {
            try {
                console.log('=== Reloading markers for difficulty:', difficulty, '===');
                
                // Wait for marker system to be ready
                await waitForMarkerSystem();
                
                // Store the current difficulty selection
                sessionStorage.setItem('selectedDifficulty', difficulty);
                console.log('Stored difficulty in sessionStorage:', difficulty);
                
                // Use the marker system's built-in setDifficulty method
                if (window.markerSystem && typeof window.markerSystem.setDifficulty === 'function') {
                    console.log('Using marker system setDifficulty method...');
                    window.markerSystem.setDifficulty(difficulty);
                    console.log('✅ Marker system updated for difficulty:', difficulty);
                } else {
                    console.log('setDifficulty not available, using manual approach...');
                    
                    // Fallback: Update map data manager
                    if (window.mapDataManager) {
                        if (typeof window.mapDataManager.setDifficulty === 'function') {
                            window.mapDataManager.setDifficulty(difficulty);
                        } else {
                            window.mapDataManager.currentDifficulty = difficulty;
                            if (window.mapDataManager.mapData && typeof window.mapDataManager.mapData.getAllTypes === 'function') {
                                window.mapDataManager.enabledTypes = new Set(window.mapDataManager.mapData.getAllTypes(difficulty));
                            }
                        }
                        console.log('✅ Map data manager updated for difficulty:', difficulty);
                    }
                    
                    // Update floor control
                    if (window.floorControl && typeof window.floorControl.setDifficulty === 'function') {
                        window.floorControl.setDifficulty(difficulty);
                        console.log('✅ Floor control updated for difficulty:', difficulty);
                    }
                    
                    // Update markers
                    if (window.markerSystem && typeof window.markerSystem.updateMarkers === 'function') {
                        window.markerSystem.updateMarkers();
                        console.log('✅ Markers updated for difficulty:', difficulty);
                    }
                }
                
                // Force map refresh
                setTimeout(() => {
                    if (window.interactive_map && window.interactive_map.getMap()) {
                        window.interactive_map.getMap().invalidateSize();
                    }
                }, 100);
                
                console.log('=== ✅ Markers successfully reloaded for difficulty:', difficulty, '===');
                
            } catch (error) {
                console.error('=== ❌ Error reloading markers for difficulty:', error, '===');
                showNotification(`Error loading ${difficulty} markers: ${error.message}`, 'error');
            }
        }
        
        function switchMap(mapName) {
            if (mapName && mapName !== sessionStorage.getItem('selectedMap')) {
                sessionStorage.setItem('selectedMap', mapName);
                // Reload the page to load the new map
                window.location.reload();
            }
        }
        
        function switchDifficulty(difficulty) {
            if (difficulty) {
                sessionStorage.setItem('selectedDifficulty', difficulty);
                console.log('Difficulty switched to:', difficulty);
                
                // Apply difficulty-specific settings
                applyDifficultySettings(difficulty);
                
                // Reload markers for the new difficulty
                reloadMarkersForDifficulty(difficulty);
                
                // Show notification
                showNotification(`Difficulty changed to: ${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}`);
            }
        }
        
        function applyDifficultySettings(difficulty) {
            // Apply different marker visibility or map features based on difficulty
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                
                // Log the difficulty being applied
                console.log(`Applying ${difficulty} difficulty settings...`);
                
                // Update any difficulty-specific UI elements or features
                switch(difficulty) {
                    case 'normal':
                        // Normal mode - all features available
                        console.log('Normal mode: All markers and features visible');
                        break;
                    case 'hard':
                        // Hard mode - reduced assistance
                        console.log('Hard mode: Reduced marker assistance');
                        break;
                    case 'nightmare':
                        // Nightmare mode - minimal assistance
                        console.log('Nightmare mode: Minimal marker assistance');
                        break;
                    case 'lockdown':
                        // Lockdown mode - special restrictions
                        console.log('Lockdown mode: Special restrictions applied');
                        break;
                    case 'forbidden':
                        // Forbidden zone - maximum difficulty
                        console.log('Forbidden mode: Maximum difficulty settings');
                        break;
                    default:
                        // Default settings
                        console.log('Default difficulty settings applied');
                        break;
                }
                
                // Future: Add difficulty-specific features here
                // For now, we'll just ensure the markers are properly loaded for the difficulty
                if (window.markerSystem && typeof window.markerSystem.updateMarkers === 'function') {
                    // Ensure markers are updated for the current difficulty
                    setTimeout(() => {
                        window.markerSystem.updateMarkers();
                        console.log(`Markers updated for ${difficulty} difficulty`);
                    }, 100);
                }
                
                console.log(`✅ ${difficulty} difficulty settings applied successfully`);
            }
        }
        
        // Update map name when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🚀 DOM loaded, initializing selectors...');
            
            // Set up protection immediately
            protectDropdownFromClearing();
            
            // Initialize selectors with error handling
            try {
                await initializeMapAndDifficultySelectors();
                updateMapName();
                initializeSidebarTabs();
                
                // Wait for marker system to be ready
                console.log('⏳ Waiting for marker system to be ready...');
                await waitForMarkerSystem();
                
                // Verify dropdown is still populated after all initialization
                const difficultySelector = document.getElementById('difficulty-selector');
                console.log('🔍 Final check - Difficulty dropdown has', difficultySelector?.options.length || 0, 'options');
                
                if (difficultySelector && difficultySelector.options.length > 0) {
                    console.log('✅ Difficulty selector populated, setting initial difficulty');
                    const savedDifficulty = sessionStorage.getItem('selectedDifficulty');
                    if (savedDifficulty && difficultySelector.querySelector(`option[value="${savedDifficulty}"]`)) {
                        difficultySelector.value = savedDifficulty;
                        console.log('Set difficulty selector to saved:', savedDifficulty);
                        // Don't apply difficulty settings during initialization - let the marker system handle it naturally
                    } else if (difficultySelector.options.length > 0) {
                        difficultySelector.value = difficultySelector.options[0].value;
                        console.log('Set difficulty selector to default:', difficultySelector.options[0].value);
                        // Don't apply difficulty settings during initialization
                    }
                } else {
                    console.warn('⚠️ Difficulty dropdown is empty after initialization!');
                    // Try to reinitialize
                    const currentMap = sessionStorage.getItem('selectedMap') || 'arena-breakout';
                    console.log('🔄 Attempting to reload difficulties for:', currentMap);
                    await loadDifficultiesForMap(currentMap);
                }
                
                // Force refresh floor selector after everything is initialized
                console.log('🏢 Attempting to refresh floor selector after initialization...');
                setTimeout(() => {
                    if (window.forceRefreshFloorSelector) {
                        window.forceRefreshFloorSelector();
                    }
                }, 2000);
                
                console.log('✅ Initialization complete');
                
            } catch (error) {
                console.error('❌ Error during initialization:', error);
            }
        });
        
        // Make functions globally accessible
        window.toggleSidebar = toggleSidebar;
        window.openSidebar = openSidebar;
        window.closeSidebar = closeSidebar;
        window.resetMapView = resetMapView;
        window.updateMapName = updateMapName;
        
        // Modern Sidebar Tab Functionality
        function initializeSidebarTabs() {
            const tabLinks = document.querySelectorAll('.leaflet-sidebar-tabs a[role="tab"]');
            const tabPanes = document.querySelectorAll('.leaflet-sidebar-pane');
            const sidebar = document.getElementById('sidebar');
            
            // Function to show a specific tab
            function showTab(targetId) {
                // Check if the clicked tab is already active
                const clickedTab = document.querySelector(`a[href="#${targetId}"]`);
                const isAlreadyActive = clickedTab && clickedTab.parentElement.classList.contains('active');
                
                // If tab is already active and sidebar is open, close the sidebar
                if (isAlreadyActive && sidebar && !sidebar.classList.contains('collapsed')) {
                    closeSidebar();
                    return;
                }
                
                // Hide all panes
                tabPanes.forEach(pane => {
                    pane.classList.remove('active');
                });
                
                // Remove active class from all tabs
                tabLinks.forEach(link => {
                    link.parentElement.classList.remove('active');
                });
                
                // Show target pane
                const targetPane = document.getElementById(targetId);
                if (targetPane) {
                    targetPane.classList.add('active');
                }
                
                // Add active class to clicked tab
                const activeTab = document.querySelector(`a[href="#${targetId}"]`);
                if (activeTab) {
                    activeTab.parentElement.classList.add('active');
                }
                
                // Open sidebar when tab is clicked
                if (sidebar && sidebar.classList.contains('collapsed')) {
                    openSidebar();
                }
            }
            
            // Add click event listeners to tabs
            tabLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const href = this.getAttribute('href');
                    const targetId = href.substring(1); // Remove the # symbol
                    showTab(targetId);
                });
            });
            
            // Add click event listeners to close buttons
            document.querySelectorAll('.leaflet-sidebar-close').forEach(closeBtn => {
                closeBtn.addEventListener('click', function() {
                    closeSidebar();
                });
            });
            
            // Set up first tab as active by default
            if (tabLinks.length > 0) {
                const firstTabHref = tabLinks[0].getAttribute('href');
                const firstTabId = firstTabHref.substring(1);
                
                // Set up first tab as active
                tabPanes.forEach(pane => pane.classList.remove('active'));
                tabLinks.forEach(link => link.parentElement.classList.remove('active'));
                
                const targetPane = document.getElementById(firstTabId);
                if (targetPane) {
                    targetPane.classList.add('active');
                }
                
                const activeTab = document.querySelector(`a[href="#${firstTabId}"]`);
                if (activeTab) {
                    activeTab.parentElement.classList.add('active');
                }
            }
            
            // Always start with sidebar collapsed for clean look
            if (sidebar) {
                sidebar.classList.add('collapsed');
            }
        }
        // Global function access
        window.toggleSidebar = toggleSidebar;
        window.openSidebar = openSidebar;
        window.closeSidebar = closeSidebar;
        window.resetMapView = resetMapView;
        window.updateMapName = updateMapName;
        
        // Handle window resize for responsive behavior
        window.addEventListener('resize', function() {
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                // Always keep collapsed on resize for consistency
                sidebar.classList.add('collapsed');
                adjustMapControls();
            }
        });
    </script>

    <!-- Enhanced Sidebar Features Implementation -->
    <script>
        // Global variables for sidebar features
        let customMarkers = [];
        let drawingLayers = [];
        let isPlacingMarker = false;
        let tempMarkerIcon = null;
        let currentFloor = 0; // Use numeric floor values to match main floor control
        let availableFloors = [];
        let sidebarFeaturesInitialized = false; // Prevent multiple initializations

        // Initialize all sidebar features
        function initializeSidebarFeatures() {
            // Prevent multiple initializations
            if (sidebarFeaturesInitialized) {
                console.log('Sidebar features already initialized, skipping...');
                return;
            }
            
            console.log('Initializing sidebar features...');
            sidebarFeaturesInitialized = true;
            
            // Initialize bulletproof protection for existing markers FIRST
            initializeExistingMarkerProtection();
            
            initializeCustomMarkers();
            initializeFloorSelection();
            initializeDrawingTools();
            initializeSettingsTab();
        }

        // ===============================
        // BULLETPROOF EXISTING MARKERS
        // ===============================
        
        // Apply bulletproof protection to existing markers on the map
        function protectExistingMarkers() {
            if (!window.interactive_map || !window.interactive_map.getMap()) {
                return;
            }
            
            const map = window.interactive_map.getMap();
            
            // Find all existing markers with the old marker system
            const existingMarkers = document.querySelectorAll('.custom-marker .marker-circle');
            
            existingMarkers.forEach(markerCircle => {
                const markerInner = markerCircle.querySelector('.marker-inner');
                const markerContainer = markerCircle.closest('.leaflet-marker-icon');
                
                // ULTRA AGGRESSIVE protection to prevent flicker
                const protectCircle = () => {
                    // Force the parent container to behave
                    if (markerContainer) {
                        const currentTransform = markerContainer.style.transform;
                        if (currentTransform && (currentTransform.includes('scale') || currentTransform.includes('matrix'))) {
                            // Remove scale transforms but keep position
                            const translateMatch = currentTransform.match(/translate[3d]*\([^)]+\)/);
                            const newTransform = translateMatch ? translateMatch[0] : '';
                            markerContainer.style.setProperty('transform', newTransform, 'important');
                        }
                        markerContainer.style.setProperty('transform-origin', 'center center', 'important');
                    }
                    
                    // Force marker circle to stay circular
                    markerCircle.style.setProperty('width', '18px', 'important');
                    markerCircle.style.setProperty('height', '18px', 'important');
                    markerCircle.style.setProperty('border-radius', '50%', 'important');
                    markerCircle.style.setProperty('aspect-ratio', '1 / 1', 'important');
                    markerCircle.style.setProperty('transform', 'none', 'important');
                    markerCircle.style.setProperty('transform-origin', 'center center', 'important');
                    markerCircle.style.setProperty('will-change', 'auto', 'important');
                    markerCircle.style.setProperty('transition', 'none', 'important');
                    markerCircle.style.setProperty('display', 'flex', 'important');
                    markerCircle.style.setProperty('align-items', 'center', 'important');
                    markerCircle.style.setProperty('justify-content', 'center', 'important');
                    markerCircle.style.setProperty('box-sizing', 'border-box', 'important');
                    markerCircle.style.setProperty('flex-shrink', '0', 'important');
                    markerCircle.style.setProperty('flex-grow', '0', 'important');
                    
                    if (markerInner) {
                        markerInner.style.setProperty('width', '8px', 'important');
                        markerInner.style.setProperty('height', '8px', 'important');
                        markerInner.style.setProperty('border-radius', '50%', 'important');
                        markerInner.style.setProperty('aspect-ratio', '1 / 1', 'important');
                        markerInner.style.setProperty('transform', 'none', 'important');
                        markerInner.style.setProperty('will-change', 'auto', 'important');
                        markerInner.style.setProperty('transition', 'none', 'important');
                        markerInner.style.setProperty('display', 'block', 'important');
                        markerInner.style.setProperty('box-sizing', 'border-box', 'important');
                        markerInner.style.setProperty('flex-shrink', '0', 'important');
                        markerInner.style.setProperty('flex-grow', '0', 'important');
                    }
                };
                
                // Apply protection IMMEDIATELY multiple times to prevent flicker
                protectCircle();
                setTimeout(protectCircle, 1);
                setTimeout(protectCircle, 5);
                setTimeout(protectCircle, 10);
                setTimeout(protectCircle, 20);
                setTimeout(protectCircle, 50);
                setTimeout(protectCircle, 100);
                
                // Monitor for changes with immediate response
                if (!markerCircle._protectionObserver) {
                    const observer = new MutationObserver(() => {
                        protectCircle();
                        // Immediate re-protection
                        setTimeout(protectCircle, 1);
                    });
                    observer.observe(markerCircle, {
                        attributes: true,
                        attributeFilter: ['style', 'class'],
                        subtree: true
                    });
                    
                    // Also observe the container
                    if (markerContainer && !markerContainer._protectionObserver) {
                        observer.observe(markerContainer, {
                            attributes: true,
                            attributeFilter: ['style', 'class', 'transform']
                        });
                        markerContainer._protectionObserver = observer;
                    }
                    
                    markerCircle._protectionObserver = observer;
                }
                
                // Very frequent protection to prevent any flicker
                if (!markerCircle._protectionInterval) {
                    markerCircle._protectionInterval = setInterval(protectCircle, 50);
                }
            });
        }
        
        // Run protection on all existing markers
        function initializeExistingMarkerProtection() {
            // Apply protection IMMEDIATELY when this function is called
            protectExistingMarkers();
            
            // Apply protection multiple times with very short delays to catch early markers
            setTimeout(protectExistingMarkers, 1);
            setTimeout(protectExistingMarkers, 10);
            setTimeout(protectExistingMarkers, 50);
            setTimeout(protectExistingMarkers, 100);
            setTimeout(protectExistingMarkers, 200);
            setTimeout(protectExistingMarkers, 500);
            setTimeout(protectExistingMarkers, 1000);
            setTimeout(protectExistingMarkers, 2000);
            
            // Set up continuous monitoring for new markers that appear
            const continuousProtection = setInterval(protectExistingMarkers, 200);
            
            // Store the interval so we can clear it later if needed
            window.markerProtectionInterval = continuousProtection;
            
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                map.on('zoomstart zoomend zoom movestart moveend viewreset', protectExistingMarkers);
                
                // CRITICAL: Apply protection immediately when map zoom changes
                map.on('zoomstart', () => {
                    protectExistingMarkers();
                    setTimeout(protectExistingMarkers, 1);
                    setTimeout(protectExistingMarkers, 10);
                });
                
                map.on('zoomend', () => {
                    protectExistingMarkers();
                    setTimeout(protectExistingMarkers, 1);
                    setTimeout(protectExistingMarkers, 10);
                    setTimeout(protectExistingMarkers, 50);
                });
            }
        }

        // ===============================
        // CUSTOM MARKERS IMPLEMENTATION
        // ===============================
        
        function initializeCustomMarkers() {
            console.log('Initializing custom markers...');
            
            const placeBtn = document.getElementById('place-marker-btn');
            const cancelBtn = document.getElementById('cancel-marker-btn');
            const deleteAllBtn = document.getElementById('delete-all-markers');
            
            if (placeBtn) {
                placeBtn.addEventListener('click', startPlacingMarker);
            }
            
            if (cancelBtn) {
                cancelBtn.addEventListener('click', cancelPlacingMarker);
            }
            
            if (deleteAllBtn) {
                deleteAllBtn.addEventListener('click', deleteAllCustomMarkers);
            }

            // Clear any existing markers before loading to prevent duplicates
            clearAllMarkersFromMap();
            customMarkers = [];
            
            // Load existing markers on init
            loadCustomMarkers();
            updateMarkerCount();
        }

        function clearAllMarkersFromMap() {
            // Remove all custom markers from the map
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                customMarkers.forEach(markerData => {
                    if (markerData.marker) {
                        map.removeLayer(markerData.marker);
                    }
                });
            }
        }

        function startPlacingMarker() {
            const nameInput = document.getElementById('marker-name');
            const name = nameInput?.value?.trim();
            
            if (!name) {
                alert('Please enter a marker name first');
                nameInput?.focus();
                return;
            }

            isPlacingMarker = true;
            const placeBtn = document.getElementById('place-marker-btn');
            const cancelBtn = document.getElementById('cancel-marker-btn');
            
            // Update UI
            if (placeBtn) {
                placeBtn.style.display = 'none';
            }
            if (cancelBtn) {
                cancelBtn.style.display = 'inline-flex';
            }

            // Add map click listener
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                map.on('click', onMapClickForMarker);
                map.getContainer().style.cursor = 'crosshair';
            }

            // Show instruction
            showNotification('Click anywhere on the map to place your marker', 'info');
        }

        function cancelPlacingMarker() {
            isPlacingMarker = false;
            const placeBtn = document.getElementById('place-marker-btn');
            const cancelBtn = document.getElementById('cancel-marker-btn');
            
            // Update UI
            if (placeBtn) {
                placeBtn.style.display = 'inline-flex';
            }
            if (cancelBtn) {
                cancelBtn.style.display = 'none';
            }

            // Remove map click listener
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                map.off('click', onMapClickForMarker);
                map.getContainer().style.cursor = '';
            }
        }

        function onMapClickForMarker(e) {
            if (!isPlacingMarker) return;

            const latlng = e.latlng;
            createCustomMarker(latlng.lat, latlng.lng);
            cancelPlacingMarker();
        }

        function createCustomMarker(lat, lng) {
            const nameInput = document.getElementById('marker-name');
            const descInput = document.getElementById('marker-description');
            const typeSelect = document.getElementById('marker-type');
            const colorInput = document.getElementById('marker-color');

            const name = nameInput?.value?.trim() || 'Custom Marker';
            const description = descInput?.value?.trim() || '';
            const type = typeSelect?.value || 'custom';
            const color = colorInput?.value || '#ff6b35';

            // Get current floor name for display
            const currentFloorName = availableFloors.find(f => f.id === currentFloor)?.name || currentFloor;

            // Create marker object
            const markerId = Date.now().toString();
            const markerData = {
                id: markerId,
                name: name,
                description: description,
                type: type,
                color: color,
                lat: lat,
                lng: lng,
                floor: currentFloor,
                floorName: currentFloorName,
                created: new Date().toISOString()
            };

            // Add to map
            const marker = addMarkerToMap(markerData);
            if (marker) {
                customMarkers.push({...markerData, marker: marker});
                saveCustomMarkers();
                updateMarkersList();
                updateMarkerCount();
                updateDataStats();

                // Clear form
                if (nameInput) nameInput.value = '';
                if (descInput) descInput.value = '';
                
                showNotification(`Marker "${name}" created on ${currentFloorName}!`, 'success');
            }
        }

        function addMarkerToMap(markerData) {
            if (!window.interactive_map || !window.interactive_map.getMap()) {
                return null;
            }

            const map = window.interactive_map.getMap();
            
            // Create ultra-robust marker with maximum zoom protection
            const markerHtml = `
                <div class="custom-marker-icon zoom-proof-marker" style="
                    width: 20px !important;
                    height: 20px !important;
                    border: 3px solid white !important;
                    border-radius: 50% !important;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4) !important;
                    position: relative !important;
                    display: block !important;
                    transform-origin: center center !important;
                    transition: none !important;
                    aspect-ratio: 1 / 1 !important;
                    min-width: 20px !important;
                    min-height: 20px !important;
                    max-width: 20px !important;
                    max-height: 20px !important;
                    flex-shrink: 0 !important;
                    flex-grow: 0 !important;
                    box-sizing: border-box !important;
                    overflow: hidden !important;
                    background-clip: padding-box !important;
                    will-change: auto !important;
                    transform: none !important;
                    transform-style: flat !important;
                    backface-visibility: hidden !important;
                    --marker-color: ${markerData.color};
                " data-marker-id="${markerData.id}">
                    <div class="marker-inner-circle" style="
                        content: '' !important;
                        position: absolute !important;
                        top: 0 !important;
                        left: 0 !important;
                        right: 0 !important;
                        bottom: 0 !important;
                        width: 100% !important;
                        height: 100% !important;
                        background-color: ${markerData.color} !important;
                        border-radius: 50% !important;
                        z-index: 1 !important;
                        box-sizing: border-box !important;
                        aspect-ratio: 1 / 1 !important;
                        transform: none !important;
                        will-change: auto !important;
                    "></div>
                </div>
            `;
            
            // Create custom marker icon with ultra-bulletproof settings
            const markerIcon = L.divIcon({
                html: markerHtml,
                className: 'custom-marker-wrapper-ultra-bulletproof',
                iconSize: [26, 26], // Slightly larger to account for border
                iconAnchor: [13, 13], // Center anchor
                popupAnchor: [0, -13] // Popup appears above marker
            });

            // Create marker
            const marker = L.marker([markerData.lat, markerData.lng], {
                icon: markerIcon,
                riseOnHover: true // Brings marker to front on hover
            }).addTo(map);
            
            // NUCLEAR OPTION: Complete zoom transform override
            const aggressiveProtectMarkerShape = () => {
                const markerElement = marker.getElement();
                if (markerElement) {
                    // FORCE the marker container to ignore ALL transforms
                    const currentTransform = markerElement.style.transform;
                    if (currentTransform && (currentTransform.includes('scale') || currentTransform.includes('matrix'))) {
                        // Extract only translate values, remove scale/matrix transforms
                        const translateMatch = currentTransform.match(/translate[3d]*\([^)]+\)/);
                        const newTransform = translateMatch ? translateMatch[0] : '';
                        markerElement.style.setProperty('transform', newTransform, 'important');
                    }
                    
                    markerElement.style.setProperty('transform-origin', 'center center', 'important');
                    markerElement.style.setProperty('image-rendering', 'crisp-edges', 'important');
                    markerElement.style.setProperty('will-change', 'auto', 'important');
                    
                    const iconElement = markerElement.querySelector('.custom-marker-icon');
                    const innerElement = markerElement.querySelector('.marker-inner-circle');
                    
                    if (iconElement) {
                        // NUCLEAR: Lock dimensions with computed style override
                        iconElement.style.setProperty('width', '20px', 'important');
                        iconElement.style.setProperty('height', '20px', 'important');
                        iconElement.style.setProperty('min-width', '20px', 'important');
                        iconElement.style.setProperty('min-height', '20px', 'important');
                        iconElement.style.setProperty('max-width', '20px', 'important');
                        iconElement.style.setProperty('max-height', '20px', 'important');
                        iconElement.style.setProperty('border-radius', '50%', 'important');
                        iconElement.style.setProperty('aspect-ratio', '1 / 1', 'important');
                        iconElement.style.setProperty('transform', 'none', 'important');
                        iconElement.style.setProperty('transform-style', 'flat', 'important');
                        iconElement.style.setProperty('will-change', 'auto', 'important');
                        iconElement.style.setProperty('transition', 'none', 'important');
                        iconElement.style.setProperty('flex-shrink', '0', 'important');
                        iconElement.style.setProperty('flex-grow', '0', 'important');
                        iconElement.style.setProperty('display', 'block', 'important');
                        iconElement.style.setProperty('box-sizing', 'border-box', 'important');
                    }
                    
                    if (innerElement) {
                        // NUCLEAR: Lock inner circle with computed style override
                        innerElement.style.setProperty('width', '100%', 'important');
                        innerElement.style.setProperty('height', '100%', 'important');
                        innerElement.style.setProperty('border-radius', '50%', 'important');
                        innerElement.style.setProperty('transform', 'none', 'important');
                        innerElement.style.setProperty('transform-style', 'flat', 'important');
                        innerElement.style.setProperty('will-change', 'auto', 'important');
                        innerElement.style.setProperty('aspect-ratio', '1 / 1', 'important');
                        innerElement.style.setProperty('display', 'block', 'important');
                        innerElement.style.setProperty('box-sizing', 'border-box', 'important');
                    }
                }
            };
            
            // Apply protection immediately and VERY frequently
            setTimeout(aggressiveProtectMarkerShape, 1);
            setTimeout(aggressiveProtectMarkerShape, 10);
            setTimeout(aggressiveProtectMarkerShape, 50);
            setTimeout(aggressiveProtectMarkerShape, 100);
            setTimeout(aggressiveProtectMarkerShape, 200);
            setTimeout(aggressiveProtectMarkerShape, 500);
            
            // Monitor for ANY style changes and zoom events with high frequency
            const aggressiveObserver = new MutationObserver(() => {
                aggressiveProtectMarkerShape();
                // Additional protection after a brief delay
                setTimeout(aggressiveProtectMarkerShape, 1);
            });
            
            setTimeout(() => {
                const markerElement = marker.getElement();
                if (markerElement) {
                    aggressiveObserver.observe(markerElement, { 
                        attributes: true, 
                        subtree: true,
                        attributeFilter: ['style', 'class', 'transform'],
                        childList: true
                    });
                    
                    // ALSO observe the parent leaflet container
                    const parentContainer = markerElement.closest('.leaflet-marker-pane');
                    if (parentContainer) {
                        aggressiveObserver.observe(parentContainer, {
                            attributes: true,
                            subtree: true,
                            attributeFilter: ['style', 'class', 'transform']
                        });
                    }
                }
            }, 50);
            
            // Listen for ALL zoom and transform events
            map.on('zoomstart zoomend zoom movestart moveend viewreset', aggressiveProtectMarkerShape);
            
            // ULTRA AGGRESSIVE: Use setInterval for continuous protection
            const protectionInterval = setInterval(aggressiveProtectMarkerShape, 50);
            
            // Store cleanup function for later use
            marker._cleanupProtection = () => {
                aggressiveObserver.disconnect();
                clearInterval(protectionInterval);
                map.off('zoomstart zoomend zoom movestart moveend viewreset', aggressiveProtectMarkerShape);
            };

            // Add popup
            const popupContent = `
                <div class="custom-marker-popup">
                    <h4>${markerData.name}</h4>
                    ${markerData.description ? `<p>${markerData.description}</p>` : ''}
                    <div class="marker-meta">
                        <span class="marker-type-badge">${markerData.type}</span>
                        <span class="marker-floor-badge">Floor: ${markerData.floorName || markerData.floor}</span>
                        <small>Created: ${new Date(markerData.created).toLocaleDateString()}</small>
                    </div>
                    <button onclick="deleteCustomMarker('${markerData.id}')" class="delete-marker-btn">
                        <i class="fas fa-trash"></i> Delete Marker
                    </button>
                </div>
            `;

            marker.bindPopup(popupContent);
            marker.bindTooltip(markerData.name, {
                direction: 'top',
                offset: [0, -10],
                className: 'marker-tooltip'
            });

            return marker;
        }

        function updateMarkersList() {
            const listContainer = document.getElementById('custom-markers-list');
            if (!listContainer) return;

            if (customMarkers.length === 0) {
                listContainer.innerHTML = `
                    <div class="no-markers">
                        <i class="fas fa-map-marker-alt"></i>
                        <p>No custom markers yet</p>
                        <small>Create your first marker by clicking "Place Marker on Map"</small>
                    </div>
                `;
                return;
            }

            const html = customMarkers.map(markerData => `
                <div class="marker-item" data-id="${markerData.id}">
                    <div class="marker-icon-preview" style="border-color: ${markerData.color}; background-color: ${markerData.color}20;">
                        <i class="fas fa-map-marker-alt" style="color: ${markerData.color};"></i>
                    </div>
                    <div class="marker-info">
                        <div class="marker-name">${markerData.name}</div>
                        <div class="marker-details">
                            <span class="marker-type-badge">${markerData.type}</span>
                            <span class="marker-floor-badge">Floor: ${markerData.floorName || markerData.floor}</span>
                            <span>${new Date(markerData.created).toLocaleDateString()}</span>
                        </div>
                    </div>
                    <div class="marker-actions-buttons">
                        <button class="marker-action-btn" onclick="panToMarker('${markerData.id}')" title="Go to marker">
                            <i class="fas fa-eye"></i>
                        </button>
                        <button class="marker-action-btn delete" onclick="deleteCustomMarker('${markerData.id}')" title="Delete marker">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');

            listContainer.innerHTML = html;
        }

        function updateMarkerCount() {
            const countSpan = document.getElementById('marker-count');
            if (countSpan) {
                countSpan.textContent = customMarkers.length;
            }
        }

        function deleteCustomMarker(markerId) {
            const markerIndex = customMarkers.findIndex(m => m.id === markerId);
            if (markerIndex === -1) return;

            const markerData = customMarkers[markerIndex];
            
            // Remove from map
            if (markerData.marker && window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                map.removeLayer(markerData.marker);
            }

            // Remove from array
            customMarkers.splice(markerIndex, 1);
            
            // Update storage and UI
            saveCustomMarkers();
            updateMarkersList();
            updateMarkerCount();
            updateDataStats();
            
            showNotification(`Marker "${markerData.name}" deleted`, 'success');
        }

        function deleteAllCustomMarkers() {
            if (customMarkers.length === 0) return;
            
            if (confirm(`Are you sure you want to delete all ${customMarkers.length} custom markers? This cannot be undone.`)) {
                // Remove all markers from map
                if (window.interactive_map && window.interactive_map.getMap()) {
                    const map = window.interactive_map.getMap();
                    customMarkers.forEach(markerData => {
                        if (markerData.marker) {
                            map.removeLayer(markerData.marker);
                        }
                    });
                }

                // Clear array and storage
                customMarkers = [];
                saveCustomMarkers();
                updateMarkersList();
                updateMarkerCount();
                
                showNotification('All custom markers deleted', 'success');
            }
        }

        function panToMarker(markerId) {
            const markerData = customMarkers.find(m => m.id === markerId);
            if (!markerData || !window.interactive_map) return;

            const map = window.interactive_map.getMap();
            if (map) {
                map.setView([markerData.lat, markerData.lng], 3);
                if (markerData.marker) {
                    markerData.marker.openPopup();
                }
            }
        }

        function saveCustomMarkers() {
            try {
                const markersToSave = customMarkers.map(m => ({
                    id: m.id,
                    name: m.name,
                    description: m.description,
                    type: m.type,
                    color: m.color,
                    lat: m.lat,
                    lng: m.lng,
                    floor: m.floor,
                    created: m.created
                }));
                localStorage.setItem('arena_breakout_custom_markers', JSON.stringify(markersToSave));
            } catch (error) {
                console.error('Failed to save custom markers:', error);
            }
        }

        function loadCustomMarkers() {
            console.log('Loading custom markers from localStorage...');
            
            try {
                const saved = localStorage.getItem('arena_breakout_custom_markers');
                if (saved) {
                    const markersData = JSON.parse(saved);
                    console.log('Found', markersData.length, 'saved markers');
                    
                    markersData.forEach(markerData => {
                        // Check if marker already exists to prevent duplicates
                        const existingMarker = customMarkers.find(m => m.id === markerData.id);
                        if (!existingMarker) {
                            const marker = addMarkerToMap(markerData);
                            if (marker) {
                                customMarkers.push({...markerData, marker: marker});
                            }
                        } else {
                            console.log('Marker', markerData.id, 'already exists, skipping...');
                        }
                    });
                    updateMarkersList();
                    updateMarkerCount();
                    console.log('Loaded', customMarkers.length, 'custom markers');
                } else {
                    console.log('No saved markers found');
                }
            } catch (error) {
                console.error('Failed to load custom markers:', error);
            }
        }

        // ===============================
        // FLOOR SELECTION IMPLEMENTATION
        // ===============================
        
        function initializeFloorSelection() {
            console.log('=== Initializing Floor Selection ===');
            
            // Listen for floor changes from the main floor control
            if (window.interactive_map && window.interactive_map.getMap()) {
                const map = window.interactive_map.getMap();
                
                // Listen for floor change events from main floor control
                map.on('floorchange', function(e) {
                    console.log('Floor change event received:', e.floor, e.floorData);
                    if (e.floor !== undefined) {
                        updateSidebarFloorSelection(e.floor, e.floorData);
                    }
                });
            }
            
            // Wait for FloorControl to be ready and then initialize
            const waitForFloorControl = () => {
                if (window.floorControl && window.floorControl.availableFloors && window.floorControl.floorData) {
                    console.log('FloorControl is ready! Initializing sidebar floor selector...');
                    console.log('Available floors from FloorControl:', window.floorControl.availableFloors);
                    console.log('Floor data from FloorControl:', Object.keys(window.floorControl.floorData));
                    
                    currentFloor = window.floorControl.currentFloor;
                    populateAvailableFloors();
                    
                    // Create the UI
                    const sidebarFloorSelector = document.getElementById('sidebar-floor-selector');
                    if (sidebarFloorSelector) {
                        createFloorSelectorUI();
                        console.log('Floor selection initialized with', availableFloors.length, 'floors');
                    } else {
                        console.error('sidebar-floor-selector element not found!');
                    }
                } else {
                    console.log('FloorControl not ready yet, waiting...');
                    setTimeout(waitForFloorControl, 500);
                }
            };
            
            // Start waiting for FloorControl
            waitForFloorControl();
        }

        function populateAvailableFloors() {
            console.log('=== Populating Available Floors ===');
            
            // Priority 1: Get floors directly from FloorControl (most reliable for consistency)
            if (window.floorControl && window.floorControl.availableFloors && window.floorControl.floorData) {
                console.log('Getting floors from FloorControl - Primary source');
                const floorControlFloors = window.floorControl.availableFloors;
                const floorData = window.floorControl.floorData;
                
                availableFloors = floorControlFloors.map(floorId => {
                    const data = floorData[floorId];
                    return {
                        id: floorId,
                        name: data?.name || `Floor ${floorId}`,
                        active: floorId === (window.floorControl.currentFloor || currentFloor),
                        mapImage: data?.mapImage
                    };
                }).sort((a, b) => b.id - a.id); // Sort descending (top floors first)
                
                console.log('✅ Populated floors from FloorControl:', availableFloors.length, 'floors:', availableFloors);
                return;
            }
            
            // Priority 2: Try to get floors from mapDataManager 
            if (window.mapDataManager && window.mapDataManager.mapData) {
                try {
                    const currentDifficulty = sessionStorage.getItem('selectedDifficulty') || 'normal';
                    const difficulty = window.mapDataManager.mapData.getDifficulty(currentDifficulty);
                    
                    if (difficulty && difficulty.levels) {
                        console.log('Getting floors from map data as fallback - found', difficulty.levels.length, 'levels');
                        availableFloors = difficulty.levels.map(level => ({
                            id: level.floor,
                            name: level.name,
                            active: level.floor === currentFloor,
                            mapImage: level.mapImage
                        })).sort((a, b) => b.id - a.id); // Sort descending (top floors first)
                        
                        console.log('✅ Populated floors from map data:', availableFloors);
                        return;
                    }
                } catch (error) {
                    console.warn('Error getting floors from map data:', error);
                }
            }

            // Priority 3: Default floors if no data sources available
            console.log('Using default floors as final fallback');
            availableFloors = [
                { id: 0, name: 'Ground Floor', active: true, mapImage: 'map.png' },
                { id: -1, name: 'Basement', active: false, mapImage: 'armory-ground.png' }
            ];
            
            console.log('Final availableFloors:', availableFloors);
        }

        function createFloorSelectorUI() {
            const container = document.getElementById('sidebar-floor-selector');
            if (!container) {
                console.error('sidebar-floor-selector container not found');
                return;
            }

            // Ensure we have floor data
            populateAvailableFloors();

            if (availableFloors.length === 0) {
                container.innerHTML = '<p class="no-floors">No floor data available</p>';
                return;
            }

            // Create floor selector HTML
            const html = `
                <div class="floor-info-header">
                    <h4><i class="fas fa-building"></i> Available Floors</h4>
                    <p class="floor-description">Click on a floor to switch between different map levels.</p>
                </div>
                <div class="floor-selector-grid">
                    ${availableFloors.map(floor => {
                        let floorLabel;
                        if (floor.id === 0) {
                            floorLabel = 'G'; // Ground floor
                        } else if (floor.id > 0) {
                            floorLabel = floor.id.toString(); // Floor 1, 2, 3, etc.
                        } else {
                            floorLabel = `B${Math.abs(floor.id)}`; // B1, B2, B3 for basements
                        }
                        
                        return `
                            <button class="floor-select-btn ${floor.active ? 'active' : ''}" 
                                    data-floor="${floor.id}"
                                    onclick="selectFloor(${floor.id})"
                                    title="Switch to ${floor.name}">
                                <div class="floor-btn-icon">
                                    <i class="fas fa-building"></i>
                                    <span class="floor-label">${floorLabel}</span>
                                </div>
                                <div class="floor-btn-text">
                                    <span class="floor-name">${floor.name}</span>
                                </div>
                            </button>
                        `;
                    }).join('')}
                </div>
                <div class="floor-info-display">
                    <div class="current-floor-info">
                        <h4>Current Floor: <span id="current-floor-display">${availableFloors.find(f => f.active)?.name || 'Ground Floor'}</span></h4>
                        <div class="floor-stats">
                            <span class="floor-count"><i class="fas fa-layer-group"></i> ${availableFloors.length} floors available</span>
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
            
            console.log('Floor selector UI created with', availableFloors.length, 'floors');
        }

        function updateSidebarFloorSelection(floorId, floorData) {
            console.log('Updating sidebar floor selection to:', floorId, floorData);
            
            // Update current floor
            currentFloor = floorId;
            
            // Update available floors active state
            availableFloors.forEach(floor => {
                floor.active = (floor.id === floorId);
            });

            // Update UI buttons
            const floorButtons = document.querySelectorAll('#sidebar-floor-selector .floor-select-btn');
            floorButtons.forEach(btn => {
                const btnFloor = parseInt(btn.dataset.floor);
                if (btnFloor === floorId) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            // Update current floor display
            const floorDisplay = document.getElementById('current-floor-display');
            if (floorDisplay) {
                // Try to get the floor name from our available floors data first
                const floorInfo = availableFloors.find(f => f.id === floorId);
                let floorName;
                
                if (floorInfo) {
                    floorName = floorInfo.name;
                } else if (floorData && floorData.name) {
                    floorName = floorData.name;
                } else {
                    // Generate a meaningful name based on floor number
                    if (floorId === 0) {
                        floorName = 'Ground Floor';
                    } else if (floorId > 0) {
                        floorName = `Floor ${floorId}`;
                    } else {
                        floorName = `Basement ${Math.abs(floorId)}`;
                    }
                }
                
                floorDisplay.textContent = floorName;
            }

            // Update the bottom-right floor indicator if it exists
            const floorIndicator = document.getElementById('current-floor-indicator');
            if (floorIndicator) {
                const floorInfo = availableFloors.find(f => f.id === floorId);
                const floorName = floorInfo?.name || floorData?.name || `Floor ${floorId}`;
                floorIndicator.textContent = floorName;
            }

            // Update custom markers visibility for new floor
            updateCustomMarkersVisibility(floorId);
            
            console.log('Sidebar floor selection updated successfully');
        }

        function selectFloor(floorId) {
            // Ensure floorId is a number (matching the main floor control system)
            floorId = typeof floorId === 'string' ? parseInt(floorId) : floorId;
            
            console.log('Sidebar floor selection:', floorId);
            
            // Update current floor tracking
            currentFloor = floorId;
            
            // Use the main floor control system to switch floors if available
            if (window.floorControl && typeof window.floorControl.switchFloor === 'function') {
                console.log('Using main floor control to switch floor');
                window.floorControl.switchFloor(floorId);
                // The updateSidebarFloorSelection will be called automatically via the floorchange event
            } else {
                console.log('Main floor control not available, using fallback');
                // Fallback: manually update the sidebar
                updateSidebarFloorSelection(floorId, { name: `Floor ${floorId}` });
                
                // Try to notify other systems
                if (window.markerSystem && typeof window.markerSystem.setFloor === 'function') {
                    window.markerSystem.setFloor(floorId);
                }
                
                showNotification(`Switched to Floor ${floorId}`, 'info');
            }
        }

        // Function to refresh floor selector when map data changes
        function refreshFloorSelector() {
            console.log('=== Refreshing floor selector with new data ===');
            
            // Wait a bit for systems to be ready
            setTimeout(() => {
                if (document.getElementById('sidebar-floor-selector')) {
                    console.log('Refreshing floor selector UI...');
                    populateAvailableFloors();
                    createFloorSelectorUI();
                    
                    // Update to current floor if available
                    if (window.floorControl && window.floorControl.currentFloor !== undefined) {
                        console.log('Updating to current floor:', window.floorControl.currentFloor);
                        updateSidebarFloorSelection(window.floorControl.currentFloor, { 
                            name: `Floor ${window.floorControl.currentFloor}` 
                        });
                    }
                    
                    console.log('✅ Floor selector refreshed successfully with', availableFloors.length, 'floors');
                } else {
                    console.warn('sidebar-floor-selector element not found');
                }
            }, 500);
        }

        // Function to force immediate refresh with retry logic
        function forceRefreshFloorSelector() {
            console.log('=== Force refreshing floor selector ===');
            
            let attempts = 0;
            const maxAttempts = 10;
            
            const attemptRefresh = () => {
                attempts++;
                console.log(`Refresh attempt ${attempts}/${maxAttempts}`);
                
                if (window.floorControl && window.floorControl.availableFloors && window.floorControl.floorData) {
                    console.log('FloorControl ready! Performing refresh...');
                    populateAvailableFloors();
                    
                    const sidebarFloorSelector = document.getElementById('sidebar-floor-selector');
                    if (sidebarFloorSelector) {
                        createFloorSelectorUI();
                        console.log('✅ Force refresh completed with', availableFloors.length, 'floors');
                    }
                } else if (attempts < maxAttempts) {
                    console.log('FloorControl not ready, retrying in 300ms...');
                    setTimeout(attemptRefresh, 300);
                } else {
                    console.warn('❌ Max refresh attempts reached, FloorControl still not ready');
                }
            };
            
            attemptRefresh();
        }

        // Make refreshFloorSelector globally available
        window.refreshFloorSelector = refreshFloorSelector;
        window.forceRefreshFloorSelector = forceRefreshFloorSelector;

        function updateCustomMarkersVisibility(activeFloor) {
            if (!window.interactive_map || !window.interactive_map.getMap()) return;

            const map = window.interactive_map.getMap();
            
            customMarkers.forEach(markerData => {
                if (markerData.marker) {
                    if (markerData.floor === activeFloor) {
                        // Show marker on current floor
                        if (!map.hasLayer(markerData.marker)) {
                            markerData.marker.addTo(map);
                        }
                    } else {
                        // Hide marker on other floors
                        if (map.hasLayer(markerData.marker)) {
                            map.removeLayer(markerData.marker);
                        }
                    }
                }
            });
        }

        // ===============================
        // DRAWING TOOLS IMPLEMENTATION
        // ===============================
        
        function initializeDrawingTools() {
            const drawButtons = document.querySelectorAll('.tool-btn');
            const clearBtn = document.getElementById('clear-drawings');
            const toggleBtn = document.getElementById('toggle-drawing-mode');
            const colorInput = document.getElementById('draw-color');
            const opacityInput = document.getElementById('draw-opacity');
            const weightInput = document.getElementById('draw-weight');

            // Add event listeners
            drawButtons.forEach(btn => {
                btn.addEventListener('click', () => activateDrawingTool(btn.dataset.tool));
            });

            if (clearBtn) {
                clearBtn.addEventListener('click', clearAllDrawings);
            }

            if (toggleBtn) {
                toggleBtn.addEventListener('click', toggleDrawingMode);
            }

            // Style controls
            if (opacityInput) {
                opacityInput.addEventListener('input', updateOpacityDisplay);
            }
            if (weightInput) {
                weightInput.addEventListener('input', updateWeightDisplay);
            }

            // Initialize drawing plugin if available
            initializeLeafletDraw();
        }

        function initializeLeafletDraw() {
            if (!window.interactive_map || !window.L || !L.PM) {
                console.log('Leaflet Draw not available');
                return;
            }

            const map = window.interactive_map.getMap();
            if (!map) return;

            // Configure drawing options
            map.pm.addControls({
                position: 'topright',
                drawCircle: false,
                drawMarker: false,
                drawCircleMarker: false,
                cutPolygon: false,
                removalMode: false,
                rotateMode: false
            });

            // Hide default controls (we'll use our custom ones)
            map.pm.removeControls();
        }

        // ===============================
        // SETTINGS TAB IMPLEMENTATION
        // ===============================
        
        function initializeSettingsTab() {
            console.log('Initializing settings tab...');
            
            const exportBtn = document.getElementById('export-all-data');
            const importBtn = document.getElementById('import-data');
            const importFile = document.getElementById('import-file');
            const hardDeleteBtn = document.getElementById('hard-delete');
            const hardResetBtn = document.getElementById('hard-reset');
            
            // Export functionality
            if (exportBtn) {
                exportBtn.addEventListener('click', exportAllData);
            }
            
            // Import functionality
            if (importBtn) {
                importBtn.addEventListener('click', () => {
                    if (importFile) {
                        importFile.click();
                    }
                });
            }
            
            if (importFile) {
                importFile.addEventListener('change', handleFileImport);
            }
            
            // Danger zone functionality
            if (hardDeleteBtn) {
                hardDeleteBtn.addEventListener('click', hardDeleteAllData);
            }
            
            if (hardResetBtn) {
                hardResetBtn.addEventListener('click', hardResetMap);
            }
            
            // Update stats
            updateDataStats();
        }

        function exportAllData() {
            try {
                const data = {
                    version: '2.0.0',
                    exportDate: new Date().toISOString(),
                    customMarkers: JSON.parse(localStorage.getItem('arena_breakout_custom_markers') || '[]'),
                    settings: {
                        selectedMap: sessionStorage.getItem('selectedMap'),
                        selectedDifficulty: sessionStorage.getItem('selectedDifficulty')
                    }
                };
                
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `arena_breakout_map_data_${new Date().toISOString().split('T')[0]}.json`;
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                showNotification('Data exported successfully!', 'success');
                
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Failed to export data', 'error');
            }
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    if (!data.version || !data.customMarkers) {
                        throw new Error('Invalid data format');
                    }
                    
                    if (confirm('This will replace all your current custom markers. Continue?')) {
                        // Clear existing markers
                        clearAllMarkersFromMap();
                        customMarkers = [];
                        
                        // Import custom markers
                        localStorage.setItem('arena_breakout_custom_markers', JSON.stringify(data.customMarkers));
                        
                        // Import settings if available
                        if (data.settings) {
                            if (data.settings.selectedMap) {
                                sessionStorage.setItem('selectedMap', data.settings.selectedMap);
                            }
                            if (data.settings.selectedDifficulty) {
                                sessionStorage.setItem('selectedDifficulty', data.settings.selectedDifficulty);
                            }
                        }
                        
                        // Reload markers
                        loadCustomMarkers();
                        updateMarkersList();
                        updateMarkerCount();
                        updateDataStats();
                        
                        showNotification(`Imported ${data.customMarkers.length} markers successfully!`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Import error:', error);
                    showNotification('Failed to import data: Invalid file format', 'error');
                }
            };
            
            reader.readAsText(file);
            
            // Reset file input
            event.target.value = '';
        }

        function hardDeleteAllData() {
            if (confirm('⚠️ This will permanently delete ALL your custom markers and saved data. This cannot be undone! Continue?')) {
                if (confirm('Are you absolutely sure? This will delete everything!')) {
                    try {
                        // Clear localStorage
                        localStorage.removeItem('arena_breakout_custom_markers');
                        
                        // Clear custom markers from map
                        clearAllMarkersFromMap();
                        customMarkers = [];
                        
                        // Update UI
                        updateMarkersList();
                        updateMarkerCount();
                        updateDataStats();
                        
                        showNotification('All custom data deleted', 'success');
                        
                    } catch (error) {
                        console.error('Hard delete error:', error);
                        showNotification('Failed to delete data', 'error');
                    }
                }
            }
        }

        function hardResetMap() {
            if (confirm('This will reset the map to its initial position and zoom. Continue?')) {
                try {
                    if (window.interactive_map && window.interactive_map.getMap()) {
                        const map = window.interactive_map.getMap();
                        
                        // Reset to default bounds
                        const mapBounds = [[0, 240], [2158, 4318]];
                        map.fitBounds(mapBounds, {
                            padding: [50, 50],
                            maxZoom: -1
                        });
                        
                        showNotification('Map view reset to default', 'success');
                    }
                } catch (error) {
                    console.error('Hard reset error:', error);
                    showNotification('Failed to reset map', 'error');
                }
            }
        }

        function updateDataStats() {
            // Update marker count
            const markersCount = document.getElementById('stats-markers');
            if (markersCount) {
                markersCount.textContent = customMarkers.length;
            }
            
            // Calculate storage usage
            const storageUsed = document.getElementById('stats-storage');
            if (storageUsed) {
                try {
                    const markersData = localStorage.getItem('arena_breakout_custom_markers') || '[]';
                    const sizeInBytes = new Blob([markersData]).size;
                    const sizeInKB = (sizeInBytes / 1024).toFixed(1);
                    storageUsed.textContent = `${sizeInKB} KB`;
                } catch (error) {
                    storageUsed.textContent = '0 KB';
                }
            }
        }

        function activateDrawingTool(tool) {
            if (!window.interactive_map || !window.L || !L.PM) {
                showNotification('Drawing tools not available', 'error');
                return;
            }

            const map = window.interactive_map.getMap();
            if (!map) return;

            // Deactivate current drawing mode
            map.pm.disableGlobalDragMode();
            map.pm.disableGlobalEditMode();
            map.pm.disableGlobalRemovalMode();

            // Get style options
            const color = document.getElementById('draw-color')?.value || '#ff6b35';
            const opacity = parseFloat(document.getElementById('draw-opacity')?.value || '0.7');
            const weight = parseInt(document.getElementById('draw-weight')?.value || '3');

            const style = {
                color: color,
                fillColor: color,
                fillOpacity: opacity * 0.3,
                opacity: opacity,
                weight: weight
            };

            // Update button states
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-tool="${tool}"]`)?.classList.add('active');

            // Activate drawing mode
            switch (tool) {
                case 'line':
                    map.pm.enableDraw('Line', { templineStyle: style, hintlineStyle: style });
                    break;
                case 'polygon':
                    map.pm.enableDraw('Polygon', { templineStyle: style, hintlineStyle: style });
                    break;
                case 'circle':
                    map.pm.enableDraw('Circle', style);
                    break;
                case 'rectangle':
                    map.pm.enableDraw('Rectangle', style);
                    break;
            }

            // Add creation listener
            map.off('pm:create');
            map.on('pm:create', function(e) {
                const layer = e.layer;
                layer.setStyle(style);
                drawingLayers.push(layer);
                showNotification(`${tool} drawn successfully`, 'success');
            });

            showNotification(`${tool} drawing mode activated. Click on the map to start drawing.`, 'info');
        }

        function clearAllDrawings() {
            if (drawingLayers.length === 0) {
                showNotification('No drawings to clear', 'info');
                return;
            }

            if (confirm(`Clear all ${drawingLayers.length} drawings?`)) {
                const map = window.interactive_map.getMap();
                if (map) {
                    drawingLayers.forEach(layer => {
                        map.removeLayer(layer);
                    });
                }
                drawingLayers = [];
                showNotification('All drawings cleared', 'success');
            }
        }

        function toggleDrawingMode() {
            if (!window.interactive_map || !window.L || !L.PM) return;

            const map = window.interactive_map.getMap();
            const toggleBtn = document.getElementById('toggle-drawing-mode');
            
            if (map && map.pm.globalDrawModeEnabled()) {
                map.pm.disableGlobalDragMode();
                map.pm.disableGlobalEditMode();
                map.pm.disableGlobalRemovalMode();
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                if (toggleBtn) {
                    toggleBtn.innerHTML = '<i class="fas fa-eye"></i> Enable Drawing';
                }
                showNotification('Drawing mode disabled', 'info');
            } else {
                if (toggleBtn) {
                    toggleBtn.innerHTML = '<i class="fas fa-eye-slash"></i> Disable Drawing';
                }
                showNotification('Select a drawing tool to start drawing', 'info');
            }
        }

        function updateOpacityDisplay() {
            const opacityInput = document.getElementById('draw-opacity');
            const opacityValue = document.getElementById('opacity-value');
            if (opacityInput && opacityValue) {
                opacityValue.textContent = Math.round(opacityInput.value * 100) + '%';
            }
        }

        function updateWeightDisplay() {
            const weightInput = document.getElementById('draw-weight');
            const weightValue = document.getElementById('weight-value');
            if (weightInput && weightValue) {
                weightValue.textContent = weightInput.value + 'px';
            }
        }

        // ===============================
        // NOTIFICATION SYSTEM
        // ===============================
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.innerHTML = `
                <div class="notification-content">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;

            // Add to page
            document.body.appendChild(notification);

            // Show with animation
            setTimeout(() => notification.classList.add('show'), 100);

            // Remove after delay
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // ===============================
        // GLOBAL FUNCTIONS FOR HTML
        // ===============================
        
        window.deleteCustomMarker = deleteCustomMarker;
        window.panToMarker = panToMarker;
        window.selectFloor = selectFloor;

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing mobile navigation and features...');
            
            // Initialize mobile navigation
            initMobileNavigation();
            
            // START PROTECTION IMMEDIATELY
            initializeExistingMarkerProtection();
            
            // Wait for map to initialize
            setTimeout(() => {
                if (!sidebarFeaturesInitialized) {
                    initializeSidebarFeatures();
                }
            }, 1000);
        });

        // Also initialize when interactive map is loaded (but only if not already initialized)
        if (window.interactive_map && !sidebarFeaturesInitialized) {
            console.log('Interactive map already available, initializing sidebar features...');
            // START PROTECTION IMMEDIATELY
            initializeExistingMarkerProtection();
            initializeSidebarFeatures();
        }

        // Listen for floor control initialization (but only if not already initialized)
        window.addEventListener('load', function() {
            // START PROTECTION IMMEDIATELY ON LOAD
            initializeExistingMarkerProtection();
            
            setTimeout(() => {
                if (window.floorControl && document.getElementById('sidebar-floor-selector') && !sidebarFeaturesInitialized) {
                    console.log('Floor control loaded, initializing sidebar features...');
                    // Re-initialize floor selection with proper data
                    initializeSidebarFeatures();
                }
            }, 2000);
        });
        
        // EMERGENCY EARLY PROTECTION - Start immediately when script loads
        if (document.readyState === 'loading') {
            // Document still loading
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initializeExistingMarkerProtection, 1);
            });
        } else {
            // Document already loaded
            setTimeout(initializeExistingMarkerProtection, 1);
        }
    </script>

    <!-- Notification Styles -->
    <style>
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            background: var(--bg-panel);
            border: 2px solid;
            border-radius: 8px;
            padding: 12px 16px;
            transform: translateX(400px);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: var(--shadow-orange);
            max-width: 300px;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification-success {
            border-color: #28a745;
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(40, 167, 69, 0.05));
        }

        .notification-error {
            border-color: #dc3545;
            background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), rgba(220, 53, 69, 0.05));
        }

        .notification-info {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, rgba(255, 140, 0, 0.1), rgba(255, 140, 0, 0.05));
        }

        .notification-content {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
        }

        .notification-success .notification-content i {
            color: #28a745;
        }

        .notification-error .notification-content i {
            color: #dc3545;
        }

        .notification-info .notification-content i {
            color: var(--primary-color);
        }

        /* Custom marker badges */
        .marker-type-badge {
            background: var(--gradient-primary);
            color: var(--text-primary);
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: capitalize;
        }

        .marker-floor-badge {
            background: linear-gradient(135deg, #17a2b8, #138496);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: capitalize;
        }

        .current-floor-indicator {
            margin-top: 8px;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(23, 162, 184, 0.1), rgba(19, 132, 150, 0.05));
            border: 1px solid rgba(23, 162, 184, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .current-floor-indicator i {
            color: #17a2b8;
        }

        .current-floor-indicator strong {
            color: #17a2b8;
            font-weight: 700;
        }

        /* Settings tab styles */
        .data-info {
            background: var(--bg-light);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 16px;
            color: var(--text-secondary);
            font-size: 13px;
            line-height: 1.4;
        }

        .data-stats {
            background: var(--bg-darker);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-top: 16px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .stat-row:not(:last-child) {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 8px;
            padding-bottom: 8px;
        }

        .stat-label {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .stat-value {
            color: var(--primary-color);
            font-weight: 600;
            font-size: 13px;
        }

        /* Floor selector styles */
        .floor-info-header {
            margin-bottom: 16px;
            text-align: center;
        }

        .floor-info-header h4 {
            margin: 0 0 8px 0;
            color: var(--primary-color);
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .floor-info-header .floor-description {
            margin: 0;
            color: #888888;
            font-size: 13px;
            line-height: 1.4;
        }

        .floor-selector-grid {
              scrollbar-color: #ffffff #555555;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
            padding: 4px;
        }

        .floor-select-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 16px 12px;
            background: #262626;
            border: 2px solid #555555;
            border-radius: 12px;
            color: #cccccc;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
            font-weight: 600;
            position: relative;
            overflow: hidden;
            min-height: 80px;
        }

        .floor-select-btn:hover {
            background: #404040;
            border-color: #ff8c00;
            color: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 139, 71, 0.25);
        }

        .floor-select-btn.active {
            background: linear-gradient(135deg, #ff8c00, #ff6b35);
            border-color: #ff8c00;
            color: white;
            box-shadow: 0 6px 20px rgba(255, 139, 71, 0.4);
            transform: translateY(-1px);
        }

        .floor-btn-icon {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .floor-btn-icon i {
            font-size: 20px;
        }

        .floor-label {
            font-size: 16px;
            font-weight: bold;
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 10px;
            border-radius: 14px;
            min-width: 32px;
            text-align: center;
            line-height: 1;
        }

        .floor-select-btn.active .floor-label {
            background: rgba(255, 255, 255, 0.35);
            font-weight: 800;
        }

        .floor-btn-text {
            text-align: center;
            max-width: 100%;
            margin-top: 2px;
        }

        .floor-name {
            font-size: 10px;
            line-height: 1.2;
            opacity: 0.85;
            font-weight: 500;
        }

        .floor-select-btn.active .floor-name {
            opacity: 1;
            font-weight: 600;
        }

        .floor-info-display {
            background: #404040;
            border: 1px solid #555555;
            border-radius: 10px;
            padding: 18px;
            margin-top: 10px;
        }

        .current-floor-info h4 {
            margin: 0 0 12px 0;
            color: #ff8c00;
            font-size: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .current-floor-info h4 span {
            color: #ffffff;
            font-weight: 700;
        }

        .floor-stats {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #888888;
            font-size: 13px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #555555;
        }

        .floor-stats i {
            color: #ff8c00;
        }

        .floor-count {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .no-floors {
            text-align: center;
            color: #888888;
            font-style: italic;
            padding: 20px;
        }
    </style>
</body>

</html>
